<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hq公司一面总结</title>
      <link href="/2022/10/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/hq%E5%85%AC%E5%8F%B8%E4%B8%80%E9%9D%A2%E6%80%BB%E7%BB%93/"/>
      <url>/2022/10/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/hq%E5%85%AC%E5%8F%B8%E4%B8%80%E9%9D%A2%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="hq公司一面总结"><a href="#hq公司一面总结" class="headerlink" title="hq公司一面总结"></a>hq公司一面总结</h1><h2 id="一、数据库表的字段"><a href="#一、数据库表的字段" class="headerlink" title="一、数据库表的字段"></a>一、数据库表的字段</h2><h2 id="二、什么样的字段适合添加索引"><a href="#二、什么样的字段适合添加索引" class="headerlink" title="二、什么样的字段适合添加索引"></a>二、什么样的字段适合添加索引</h2><p>1、表的主键、外键必须有索引；<br>2、数据量超过300的表应该有索引；<br>3、经常与其他表进行连接的表，在连接字段上应该建立索引；<br>4、经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；<br>5、索引应该建在选择性高的字段上；<br>6、索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；<br>7、复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替</p><p>8、频繁进行数据操作的表，不要建立太多的索引；</p><p>9、小型表不适合建索引</p><h2 id="三、登录模块的具体阐述-session（项目）"><a href="#三、登录模块的具体阐述-session（项目）" class="headerlink" title="三、登录模块的具体阐述 session（项目）"></a>三、登录模块的具体阐述 session（项目）</h2><h2 id="四、密码加密的问题（项目）"><a href="#四、密码加密的问题（项目）" class="headerlink" title="四、密码加密的问题（项目）"></a>四、密码加密的问题（项目）</h2><h2 id="五、Springboot常用注解"><a href="#五、Springboot常用注解" class="headerlink" title="五、Springboot常用注解"></a>五、Springboot常用注解</h2><p>一、启动注解 @SpringBootApplication</p><p>@SpringBootConfiguration 注解，继承@Configuration注解，主要用于加载配置文件</p><p>@EnableAutoConfiguration 注解，开启自动配置功能</p><p>@ComponentScan 注解，主要用于组件扫描和自动装配</p><p>二、Controller 相关注解</p><p>@Controller<br>控制器，处理http请求。</p><p>@RestController 复合注解</p><p>@RestController注解相当于@ResponseBody+@Controller合在一起的作用,RestController使用的效果是将方法返回的对象直接在浏览器上展示成json格式</p><p>@RequestBody<br>通过HttpMessageConverter读取Request Body并反序列化为Object（泛指）对象</p><p>@RequestMapping<br>@RequestMapping 是 Spring Web 应用程序中最常被用到的注解之一。这个注解会将 HTTP 请求映射到 MVC 和 REST 控制器的处理方法上</p><p>@GetMapping用于将HTTP get请求映射到特定处理程序的方法注解</p><p>@PostMapping用于将HTTP post请求映射到特定处理程序的方法注解</p><p>三、获取请求参数值</p><p>@PathVariable:获取url中的数据</p><p>@RequestParam:获取请求参数的值</p><p>@RequestHeader 把Request请求header部分的值绑定到方法的参数上</p><p>@CookieValue 把Request header中关于cookie的值绑定到方法的参数上</p><p>四、注入bean相关</p><p>@Repository<br>DAO层注解</p><p>@Service</p><ul><li>@Service是@Component注解的一个特例，作用在类上</li><li>@Service注解作用域默认为单例</li><li>使用注解配置和类路径扫描时，被@Service注解标注的类会被Spring扫描并注册为Bean</li><li>@Service用于标注服务层组件,表示定义一个bean</li><li>@Service使用时没有传参数，Bean名称默认为当前类的类名，首字母小写</li><li>@Service(“serviceBeanId”)或@Service(value&#x3D;”serviceBeanId”)使用时传参数，使用value作为Bean名字</li></ul><p>@Scope作用域注解<br>@Scope作用在类上和方法上，用来配置 spring bean 的作用域，它标识 bean 的作用域</p><p>@Entity实体类注解<br>@Table(name &#x3D;”数据库表名”)，这个注解也注释在实体类上，对应数据库中相应的表。<br>@Id、@Column注解用于标注实体类中的字段，pk字段标注为@Id，其余@Column。</p><p>@Bean产生一个bean的方法<br>@Bean明确地指示了一种方法，产生一个bean的方法，并且交给Spring容器管理。支持别名@Bean(“xx-name”)</p><p>@Autowired 自动导入<br>@Autowired注解作用在构造函数、方法、方法参数、类字段以及注解上<br>@Autowired注解可以实现Bean的自动注入</p><p>@Component<br>把普通pojo实例化到spring容器中</p><p>五、导入配置文件</p><p>@PropertySource注解</p><p>@ImportResource导入xml配置文件</p><p>@Import 导入额外的配置信息</p><p>六、事务注解 @Transactional</p><p>在Spring中，事务有两种实现方式，分别是编程式事务管理和声明式事务管理两种方式</p><ul><li>编程式事务管理： 编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。</li><li>声明式事务管理： 建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务，通过@Transactional就可以进行事务操作，更快捷而且简单。推荐使用</li></ul><p>七、全局异常处理</p><p>@ControllerAdvice 统一处理异常</p><p>@ExceptionHandler 注解声明异常处理方法</p><h2 id="六、HashMap添加值的问题"><a href="#六、HashMap添加值的问题" class="headerlink" title="六、HashMap添加值的问题"></a>六、HashMap添加值的问题</h2><p>添加a，a</p><p>​        b，b</p><p>​        a，c</p><p>最后的结果{a&#x3D;c, b&#x3D;b}</p><h2 id="七、获取json和返回json"><a href="#七、获取json和返回json" class="headerlink" title="七、获取json和返回json"></a>七、获取json和返回json</h2><p>一、返回json</p><p>使用@ResponseBody注解</p><p>响应json</p><p>1.加入jackson依赖</p><p>2.将jsckson的jar包加入WEB-INF的lib文件夹</p><p>3.在对于的方法处理上加上@ResponseBody用于标记该处理方法返回json</p><p>4.或者将@Controller改成@RestController（相当于控制器中所有的方法都加上了@ResponseBody 适用于web api</p><p><strong>二、获取json</strong></p><p>1、以@RequestBody接收<br>单个参数的json数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="meta">@RequestBody</span> String username)</span><br></pre></td></tr></table></figure><p>2、以实体类方式接收<br>前端传来的是一个json对象时：{ id:1,name:xx},可以用实体类直接进行自动绑定</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="meta">@RequestBody</span> User user)</span><br></pre></td></tr></table></figure><p>3、以Map接收<br>前端传来的是一个json对象时：{ id:1,name:xx},可以用Map来获取</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="meta">@RequestBody</span> Map&lt;String,String&gt; map)</span><br></pre></td></tr></table></figure><p>4、以List接收<br>当前端传来这样一个json数组：[{ id:1,name:xx},{ id:1,name:xx},{ id:1,name:xx},…]时，用List接收</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="meta">@RequestBody</span> List&lt;User&gt; list)</span><br></pre></td></tr></table></figure><h2 id="八、sql查询语句"><a href="#八、sql查询语句" class="headerlink" title="八、sql查询语句"></a>八、sql查询语句</h2><h2 id="九、自己常用的类有哪些"><a href="#九、自己常用的类有哪些" class="headerlink" title="九、自己常用的类有哪些"></a>九、自己常用的类有哪些</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2022/10/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JVM/"/>
      <url>/2022/10/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JVM/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="一、JVM的位置"><a href="#一、JVM的位置" class="headerlink" title="一、JVM的位置"></a>一、JVM的位置</h2><p><img src="/./img/JVM0.png" alt="JVM的位置"></p><h2 id="二、JVM体系结构"><a href="#二、JVM体系结构" class="headerlink" title="二、JVM体系结构"></a>二、JVM体系结构</h2><p><img src="/./img/JVM1.png" alt="JVM体系结构"></p><p>Java栈、本地方法栈、程序计数器不会有垃圾</p><p>JVM调优：99%都在方法区和堆，大部分在调堆</p><h2 id="三、类加载器"><a href="#三、类加载器" class="headerlink" title="三、类加载器"></a>三、类加载器</h2><p>作用：加载Class文件 </p><p><img src="/./img/JVM2.png" alt="类加载器"></p><p>1.虚拟机自带的加载器</p><p>2.启动类（跟）加载器</p><p>3.扩展类加载器</p><p>4.应用程序（系统类）加载器</p><h2 id="四、双亲委派机制"><a href="#四、双亲委派机制" class="headerlink" title="四、双亲委派机制"></a>四、双亲委派机制</h2><p>1.类加载器收到类加载的请求</p><p>2.将这个请求向上委托给父加载器去完成，一直向上委托，直到启动加载器</p><p>3.启动加载器检查是否能够加载当前这个类，能加载就结束，使用当前的加载器，否则抛出异常，通知子加载器进行加载</p><p>4.重复步骤3</p><p>Class Not Found~</p><p>null：java调用不到~C、C++</p><p>例子：</p><p>​         当一个Hello.class这样的文件要被加载时。不考虑我们自定义类加载器，首先会在AppClassLoader中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器的loadClass方法。父类中同理会先检查自己是否已经加载过，如果没有再往上。注意这个过程，直到到达Bootstrap classLoader之前，都是没有哪个加载器自己选择加载的。如果父加载器无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出ClassNotFoundException。</p><h2 id="五、沙箱安全机制"><a href="#五、沙箱安全机制" class="headerlink" title="五、沙箱安全机制"></a>五、沙箱安全机制</h2><h2 id="六、native关键字、方法区"><a href="#六、native关键字、方法区" class="headerlink" title="六、native关键字、方法区"></a>六、native关键字、方法区</h2><ul><li>凡是带了native关键字的方法，说明Java的作用范围达不到了，会去调用底层C语言的库</li><li>会进入本地方法栈</li><li>会调用本地方法接口 JNI</li><li>JNI作用：扩展Java的使用，融合不同的编程语言为Java所用；最初：C、C++</li><li>Java诞生的适合 C、C++横行，想要立足，必须要有调用C、C++的程序</li><li>它在内存中专门开辟了一块标记区域：native Method Stack，登记native方法</li><li>在最终执行的时候，加载本地方法库中的方法，通过JNI</li><li>比如：Java程序驱动打印机，管理系统，Robot</li><li>调用其它接口：Socket、WebService、http~</li></ul><h4 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h4><p>程序计数器：Program Counter Register</p><p>每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的字节码（用来存储指向像一条指令的地址，也即将要执行的指令代码），在执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>Method Area</p><p>方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义，简单说，所有定义的方法的信息都保存在该区域，此区域属于共享空间</p><p><strong>静态变量、常量、类信息（构造方法、接口定义）、运行时的常量池存放在方法区中，但是实例变量存在堆内存中，和方法区无关</strong></p><p>static、final、Class模板、常量池</p><h2 id="七、栈"><a href="#七、栈" class="headerlink" title="七、栈"></a>七、栈</h2><p>喝多了吐就是栈，吃多了拉就是队列</p><p>栈：栈内存，主管程序的运行，生命周期和线程同步；</p><p>线程结束，栈内存也就释放，对于栈来说，<strong>不存在垃圾回收问题</strong></p><p>一旦线程结束，栈就over！</p><p>栈：八大基本类型+对象引用+实例的方法</p><p>栈运行原理：栈帧</p><p><img src="/./img/JVM3.png" alt="栈帧"></p><p>栈满了：StackOverFlowError</p><h4 id="栈-堆-方法区：交互关系"><a href="#栈-堆-方法区：交互关系" class="headerlink" title="栈+堆+方法区：交互关系"></a>栈+堆+方法区：交互关系</h4><p><img src="/./img/JVM4.png" alt="交互关系"></p><h4 id="一个对象实例化的过程"><a href="#一个对象实例化的过程" class="headerlink" title="一个对象实例化的过程"></a>一个对象实例化的过程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="type">int</span> age=<span class="number">90</span>;</span><br><span class="line">String name;</span><br><span class="line">Person(String n,<span class="type">int</span> a)&#123;</span><br><span class="line">name=n;</span><br><span class="line">age=a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Person p=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小倩&quot;</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><ol><li>先在方法区加载Person类信息（Person.class），只会加载一次</li><li>然后在堆里开空间（地址）</li><li>默认初始化age&#x3D;0，name&#x3D;null；</li><li>然后进行显示初始化，age&#x3D;90，name&#x3D;null；</li><li>构造器的初始化（构造器是对对象初始化，而不是创建对象），name&#x3D;”小倩”,age&#x3D;20</li><li>把对象在堆中的地址，返回给p</li></ol><p><img src="/./img/JVM5.png" alt="对象实例化"></p><h2 id="八、HotSpot和堆"><a href="#八、HotSpot和堆" class="headerlink" title="八、HotSpot和堆"></a>八、HotSpot和堆</h2><h4 id="HotSpot"><a href="#HotSpot" class="headerlink" title="HotSpot"></a>HotSpot</h4><p> SUN的JDK版本从1.3.1开始运用HotSpot<a href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&spm=1001.2101.3001.7020">虚拟机</a>， 2006年底开源，主要使用C++实现，JNI接口部分用C实现。<br>  HotSpot是较新的Java虚拟机，用来代替JIT(Just in Time)，可以大大提高Java运行的性能。<br>  Java原先是把源代码编译为<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E8%8A%82%E7%A0%81&spm=1001.2101.3001.7020">字节码</a>在虚拟机执行，这样执行速度较慢。而HotSpot将常用的部分代码编译为本地(原生，native)代码，这样显着提高了性能。<br>  HotSpot JVM 参数可以分为规则参数(standard options)和非规则参数(non-standard options)。<br>  规则参数相对稳定，在JDK未来的版本里不会有太大的改动。<br>  非规则参数则有因升级JDK而改动的可能。</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>Heap，一个JVM只有一个堆内存，堆内存的大小是可以调节的</p><p>堆内存中还要细分为三个区域：</p><h4 id="新生区（伊甸园区）"><a href="#新生区（伊甸园区）" class="headerlink" title="新生区（伊甸园区）"></a>新生区（伊甸园区）</h4><p>类：诞生和成长的地方，甚至死亡；</p><p>伊甸园，所有对象都是在伊甸园区new出来的</p><p>幸存者区（0，1）</p><h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><h4 id="永久区"><a href="#永久区" class="headerlink" title="永久区"></a>永久区</h4><p>这个区是常驻内存的，用来存放JDK自带的Class对象。Interface元数据，存储的是Java运行时的一些环境或类信息，这个区域不存在垃圾回收，关闭jvm虚拟机就会释放这个区域的内存</p><p>一个启动类，加载了大量的第三方jar包。Tomcat部署了太多的应用，大量动态生成的反射类。不断被加载，直到内存满，就会出现OOM</p><p>jdk1.6之前：永久代，常量池是在方法区</p><p>jdk1.7：永久代，但是慢慢退化，去永久代，常量池在堆中</p><p>jdk1.8之后：无永久代，常量池在元空间</p><p><img src="/./img/JVM6.png" alt="堆"></p><p>经过研究，99%对象都是临时对象！</p><p><img src="/./img/JVM7.png"></p><p>逻辑上存在，物理上不存在</p><p>默认情况下：虚拟机分配总内存 是电脑内存的1&#x2F;4，而初始化的内存 1&#x2F;64</p><p>可以手动调参</p><p>OOM：</p><ol><li><p>尝试扩大堆内存看结果</p><p><img src="/./img/JVM8.png"></p></li><li><p>分析内存，看一下哪个地方出现了问题（专业工具）</p></li></ol><p>在一个项目中，突然出现了OOM故障，那么该如何排除，那么该如何排除，研究为什么出错</p><ul><li>能够看到代码第几行出错：内存快照分析工具，MAT，Jprofiler</li><li>debug：一行行分析代码</li></ul><p>MAT，Jprofiler作用：</p><ul><li>分析Dump内存文件，快速定位内存泄漏</li><li>获得堆中的数据</li><li>获得大的对象</li><li>…</li></ul><p><img src="/./img/JVM9.png" alt="OOM"></p><p><img src="/./img/JVM10.png" alt="OOM"></p><p>-Xms 设置初始化内存分配大小 默认1&#x2F;64</p><p>-Xmx 设置最大分配内存，默认1&#x2F;4</p><p>-XX:+PrintGCDetails &#x2F;&#x2F;打印GC垃圾回收信息</p><p>-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError</p><p><img src="/./img/JVM11.png" alt="OOM"></p><p><img src="/./img/JVM12.png" alt="OOM"></p><p><img src="/./img/JVM13.png" alt="OOM"></p><p><img src="/./img/JVM14.png" alt="OOM"></p><h2 id="九、GC"><a href="#九、GC" class="headerlink" title="九、GC"></a>九、GC</h2><h3 id="1-GC垃圾回收"><a href="#1-GC垃圾回收" class="headerlink" title="1.GC垃圾回收"></a>1.GC垃圾回收</h3><p><img src="/./img/JVM15.png" alt="GC垃圾回收"></p><p>JVM在进行GC时，并不是对这三个区域统一回收，回收都是新生代</p><ul><li>新生代</li><li>幸存区（from，to）</li><li>老年区</li></ul><p>GC两种类：轻GC（普通GC），重GC（全局GC）</p><p>题目：</p><ul><li>JVM的内存模型和分区-详细到每个分区放什么</li><li>堆里面的分区有哪些？Eden、from、to，老年区，说说特点</li><li>GC算法有哪些？标记清除法，标记压缩、复制算法、引用计数器，怎么用的</li><li>轻GC和重GC分别在什么时候发生</li></ul><h3 id="引用计数法："><a href="#引用计数法：" class="headerlink" title="引用计数法："></a>引用计数法：</h3><p><img src="/./img/JVM16.png" alt="GC算法"></p><h3 id="复制算法："><a href="#复制算法：" class="headerlink" title="复制算法："></a>复制算法：</h3><p><img src="/./img/JVM17.png" alt="GC算法"></p><p><img src="/./img/JVM18.png" alt="GC算法"></p><ul><li>好处：没有内存碎片</li><li>坏处：浪费了内存空间；多了一半空间永远是空to，假设对象100%存活（极端情况）</li></ul><p>复制算法最佳使用场景：对象存活度较低的时候</p><h3 id="标记清除算法："><a href="#标记清除算法：" class="headerlink" title="标记清除算法："></a>标记清除算法：</h3><p><img src="/./img/JVM19.png" alt="GC算法"></p><ul><li>优点：不需要额外的空间</li><li>缺点：两次扫描，严重浪费时间，会产生内存碎片，</li></ul><h3 id="标记压缩算法："><a href="#标记压缩算法：" class="headerlink" title="标记压缩算法："></a>标记压缩算法：</h3><p><img src="/./img/JVM20.png" alt="GC算法"></p><h3 id="标记清除压缩："><a href="#标记清除压缩：" class="headerlink" title="标记清除压缩："></a>标记清除压缩：</h3><p>先标记清除几次，再进行压缩</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>内存效率：复制算法&gt;标记清除算法&gt;标记压缩算法（时间复杂度）</p><p>内存整齐度：复制算法&#x3D;标记压缩算法&gt;标记清除算法</p><p>内存利用率：标记压缩算法&#x3D;标记清除算&gt;复制算法</p><p>思考：没有最好，只有最合适——&gt;GC：分代收集算法</p><p>年轻代：</p><ul><li>存活率低</li><li>复制算法！</li></ul><p>老年代：</p><ul><li>区域大，存活率高</li><li>标记清除（内存碎片不是太多）+标记压缩 混合实现</li></ul><h2 id="十、JMM"><a href="#十、JMM" class="headerlink" title="十、JMM"></a>十、JMM</h2><p>Java Memory Model</p><ol><li><p>什么是JMM<br>Java内存模型（ Java Memory Model）</p></li><li><p>它是干嘛的：</p><p>作用：缓存一致性协议，用于定义数据读写的规则</p><p>JMM定义了线程工作内存和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main Memory）中，每个线程都有一个私有的本地内存（Local Memory）</p><p><img src="/./img/JVM21.png"></p><p>解决共享对象可见性问题：volatile</p><p>可见性问题：</p><p>CPU运行中的线程从主内存中拷贝共享对象obj到它的CPU缓存，把对象obj的count变量改为2，但这个变量对运行在右边CPU中的线程不可见，因为这个更改还没有flush到主存中。</p><p><strong>JMM对这八种指令的使用，制定了如下规则：</strong></p><ul><li>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write</li><li>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存<br>不允许一个线程将没有assign的数据从工作内存同步回主内存</li><li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作</li><li>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</li><li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值</li><li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量</li><li>对一个变量进行unlock操作之前，必须把此变量同步回主内存</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/2022/10/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Springboot/"/>
      <url>/2022/10/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Springboot/</url>
      
        <content type="html"><![CDATA[<h1 id="Springboot"><a href="#Springboot" class="headerlink" title="Springboot"></a>Springboot</h1><h2 id="一、打包方式"><a href="#一、打包方式" class="headerlink" title="一、打包方式"></a>一、打包方式</h2><p>引入springboot提供的插件，可以把项目直接打成一个jar包，这个jar包自带了我们整个的运行环境，，这个jar一般称为fat jar，能直接运行</p><p>进入文件夹，这个jar包cmd进入后可以直接执行 java -jar</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="二、定制化配置"><a href="#二、定制化配置" class="headerlink" title="二、定制化配置"></a>二、定制化配置</h2><ul><li>用户直接自己@Bean替换底层的组件</li><li>用户去看这个组件是获取的配置文件什么值就去修改</li><li><strong>xxxxxAutoConfiguration —&gt; 组件  —&gt; xxxxProperties里面拿值  —-&gt; application.properties</strong></li><li>也可以查官方文档</li></ul><p>（自动配置源码分析）</p><h2 id="三、handlerMapping"><a href="#三、handlerMapping" class="headerlink" title="三、handlerMapping"></a>三、handlerMapping</h2><p>如果我们需要一些自定义的映射处理我们也可以自己给容器中放HanlerMapping</p><p>比如：v1版本所有请求去哪个包下面找，v2版本所有请求去哪个包里面找</p><h2 id="四、请求体"><a href="#四、请求体" class="headerlink" title="四、请求体"></a>四、请求体</h2><p>只有post请求才有请求体</p><h2 id="五、如果cookie被禁用"><a href="#五、如果cookie被禁用" class="headerlink" title="五、如果cookie被禁用"></a>五、如果cookie被禁用</h2><p>可以用矩阵变量</p><h2 id="六、thymeleaf"><a href="#六、thymeleaf" class="headerlink" title="六、thymeleaf"></a>六、thymeleaf</h2><h3 id="1-属性取值"><a href="#1-属性取值" class="headerlink" title="1.属性取值"></a>1.属性取值</h3><p>所有域中的属性的取值，我们都使用${}，只有取国际化等等采用#{}啦@符啦</p><p>th:href&#x3D;${link}</p><p>th:href&#x3D;@{link}</p><p>两个的区别：第一个是取出link对应的值是路径，第二个是直接把link当成路径的一部分</p><h3 id="2-在纯文本里面写"><a href="#2-在纯文本里面写" class="headerlink" title="2.在纯文本里面写"></a>2.在纯文本里面写</h3><p>没在任何标签内</p><p>用行内写法（用双中括号[[]])</p><h2 id="七、表单重复提交问题"><a href="#七、表单重复提交问题" class="headerlink" title="七、表单重复提交问题"></a>七、表单重复提交问题</h2><p>最好解决办法：用重定向</p><p>（如果是转发，刷新提交的还是原来的请求，如果是重定向刷新的就是第二次请求）</p><h2 id="八、拦截器"><a href="#八、拦截器" class="headerlink" title="八、拦截器"></a>八、拦截器</h2><p>1.编写一个拦截器实现HandlerInterceptor接口</p><p>2.拦截器注册到容器中（实现WebMvcConfigurer的addInterceptors）</p><p>3.指定拦截规则（如果是拦截所有，静态资源也会被拦截）</p><h2 id="九、文件上传"><a href="#九、文件上传" class="headerlink" title="九、文件上传"></a>九、文件上传</h2><p>@RequestPart用于将multipart&#x2F;form-data类型数据映射到控制器处理方法的参数中。除了@RequestPart注解外，@RequestParam同样可以用于此类操作。</p><h2 id="yaml的用法：单双引号的区别"><a href="#yaml的用法：单双引号的区别" class="headerlink" title="yaml的用法：单双引号的区别"></a>yaml的用法：单双引号的区别</h2><p>单引号会将\n作为字符串输出 双引号会将\n作为换行输出</p><p>双引号不会转义、单引号会转义</p><h1 id="报错Error-resolving-template-template-might-not-exist-or-might-not-be-accessible解决方案"><a href="#报错Error-resolving-template-template-might-not-exist-or-might-not-be-accessible解决方案" class="headerlink" title="报错Error resolving template template might not exist or might not be accessible解决方案"></a>报错Error resolving template template might not exist or might not be accessible解决方案</h1><p>换句话说就是你给的路径找不到。<br>网上大致有这么两种解决方案：</p><p>查看你的@ResponseBody、@RestController用了没。 如果没加的话，只用@Controller默认的是你返回的是一个webapp(Resources同级文件夹)下的一个路径，而不是一个Json。这种情况的前提是是确实是一次ajax请求<br>关于返回路径前面的”&#x2F;“。这个很明显，带”&#x2F;“的是绝对路径，不带的是相对路径。一般情况下绝对路径配置到服务器上会改变，所以很多人说他们在本地没有问题，一发布就会出现问题。<br>然而这两种我都没能解决。我这个问题是由thymeleaf报出的。thymeleaf原因是thymeleaf的默认路径是&#x2F;thymeleaf&#x2F;这个文件，而我要映射到的是webapp下面最直接的index.html，也就是&#x2F;的目录下。在&#x2F;thymeleaf&#x2F;当然找不到。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="/2022/10/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SpringMVC/"/>
      <url>/2022/10/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SpringMVC/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="创建maven工程"><a href="#创建maven工程" class="headerlink" title="创建maven工程"></a>创建maven工程</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ServletAPI --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里设置成provided（已被提供），那么这个依赖对应的jar包不会存在在lib下面</p><h3 id="怎么解决浏览器解析的绝对路径："><a href="#怎么解决浏览器解析的绝对路径：" class="headerlink" title="怎么解决浏览器解析的绝对路径："></a><strong>怎么解决浏览器解析的绝对路径：</strong></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/target&#125;&quot;</span>&gt;</span>访问目标页面target.html<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>属性前面加th:，那么这个属性就会被thymeleaf解析，@{}，大括号里面放路径，当它检测到里面是绝对路径时，会自动帮我们添加上下文路径</p><h2 id="Post和Get的区别"><a href="#Post和Get的区别" class="headerlink" title="Post和Get的区别"></a>Post和Get的区别</h2><p>get：请求参数会拼接在请求地址后边，后边是请求参数名&#x3D;请求参数值&amp;请求参数名&#x3D;请求参数值</p><p>post：会把请求参数放在请求体中，请求体中的格式也是name&#x3D;value</p><h2 id="cookie数据复习"><a href="#cookie数据复习" class="headerlink" title="cookie数据复习"></a>cookie数据复习</h2><p>第一次执行getSession方法的时候会先检测请求报文中是否携带JSESSIONID的cookie，如果没有的话，说明在这个会话中是第一次创建session对象，接下来就回去创建一个httpSession对象，然后将session放在服务器所维护的map中，并且去创建一个cookie，cookie的键是固定的JSESSIONID，值是一个随机序列，这时，还会干一件事，将httpSession对象存储到我们当前服务器维护的map中，以JSESSIONID这个cookie的值也就是这个随机序列作为map集合的键，然后把session对象作为值进行存储，存储在服务器内部，然后再把cookie响应到浏览器</p><p>所有，第一次执行getSession方法时，这个cookie会存在到响应报文中，从此之后会存在于请求报文中</p><p>咱们的服务器创建并且响应到浏览器之后，以后每一次浏览器向服务器发送请求，都会携带cookie</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>框架里面用到的好多技术都是反射，当我们通过反射去创建一个类型的对象时，默认使用的是无参构造</p><h2 id="三大组件：监听器、过滤器、Servlet的执行时间分析（用什么设置编码的问题）"><a href="#三大组件：监听器、过滤器、Servlet的执行时间分析（用什么设置编码的问题）" class="headerlink" title="三大组件：监听器、过滤器、Servlet的执行时间分析（用什么设置编码的问题）"></a>三大组件：监听器、过滤器、Servlet的执行时间分析（用什么设置编码的问题）</h2><p><u>在设置请求对象的编码的时候，有一个前提条件：如果在这之前已经获取了请求参数，所设置的编码是没有任何效果的</u></p><p>（get请求不会乱码，因为tomcat已经解决了）</p><p>ServletContextListener（监听器）加载时间最早，然后是过滤器，最后是Servlet</p><p>但是监听器是监听的作用，监听ServletContext就是用来监听它创建和销毁的，所以这两个方法都是只执行一次</p><p>过滤器的话，只要设置了过滤路径，只要当前访问地址满足了过滤路径，都会被过滤器进行过滤</p><p>所以应该用过滤器设置编码</p><h2 id="结合CharacterEncodingFilter来讲解设置过滤器"><a href="#结合CharacterEncodingFilter来讲解设置过滤器" class="headerlink" title="结合CharacterEncodingFilter来讲解设置过滤器"></a>结合CharacterEncodingFilter来讲解设置过滤器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> String encoding;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> forceRequestEncoding;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> forceResponseEncoding;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CharacterEncodingFilter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.forceRequestEncoding = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">this</span>.forceResponseEncoding = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">encoding</span> <span class="operator">=</span> <span class="built_in">this</span>.getEncoding();</span><br><span class="line">        <span class="keyword">if</span> (encoding != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//所以在web.xml中要给</span></span><br><span class="line">            <span class="comment">// &lt;init-param&gt;</span></span><br><span class="line">            <span class="comment">// &lt;param-name&gt;encoding&lt;/param-name&gt;</span></span><br><span class="line">            <span class="comment">// &lt;param-value&gt;UTF-8&lt;/param-value&gt;</span></span><br><span class="line">            <span class="comment">//&lt;/init-param&gt;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isForceRequestEncoding() || request.getCharacterEncoding() == <span class="literal">null</span>) &#123;</span><br><span class="line">                request.setCharacterEncoding(encoding);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isForceResponseEncoding()) &#123;</span><br><span class="line">                response.setCharacterEncoding(encoding);</span><br><span class="line"><span class="comment">//所以在web.xml中要给</span></span><br><span class="line"><span class="comment">//&lt;init-param&gt;</span></span><br><span class="line"><span class="comment">//&lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt;</span></span><br><span class="line"><span class="comment">// &lt;param-value&gt;true&lt;/param-value&gt;</span></span><br><span class="line"><span class="comment">//&lt;/init-param&gt;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>在web.xml中配置</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="session里面的钝化和活化"><a href="#session里面的钝化和活化" class="headerlink" title="session里面的钝化和活化"></a>session里面的钝化和活化</h2><p>当服务器关闭了，但是浏览器没有关闭，会话仍然在继续，存储在session中的数据会经过序列化，序列化到磁盘上，这个叫钝化</p><p>如果浏览器仍然没有关闭，但是这个时候服务器开启了，那么它就会将钝化后文件的内容重新读取到session中</p><h2 id="mvc搭建过程"><a href="#mvc搭建过程" class="headerlink" title="mvc搭建过程"></a>mvc搭建过程</h2><p><strong>导入依赖，创建工程</strong></p><p>pom.xml</p><p><strong>配置web.xml</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置编码过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置springMVC的前端控制器DispatcherServlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>创建控制器方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建springMVC的配置文件</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--扫描组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.mvc.controller&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置视图解析器--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置thymeleaf的视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateEngine&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateResolver&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">&lt;!-- 视图前缀 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">&lt;!-- 视图后缀 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateMode&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HTML5&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="thymeleaf解析问题"><a href="#thymeleaf解析问题" class="headerlink" title="thymeleaf解析问题"></a>thymeleaf解析问题</h2><p>html里面，只有th：所对应的属性中的内容才会被解析</p><h2 id="通过servletAPI向request域对象共享数据（一般不用）"><a href="#通过servletAPI向request域对象共享数据（一般不用）" class="headerlink" title="通过servletAPI向request域对象共享数据（一般不用）"></a>通过servletAPI向request域对象共享数据（一般不用）</h2><p>首页点击超链接，然后对应相应控制器方法，然后通过原生的servletAPI往request里面共享了数据，然后通过转发跳转到success页面，通过thmeleaf获取域对象中的数据</p><h2 id="ModleAndView"><a href="#ModleAndView" class="headerlink" title="ModleAndView"></a>ModleAndView</h2><p>不管用的什么方法，最终都是将模型数据和视图封装成ModleAndView对象</p><h2 id="转发和重定向区别"><a href="#转发和重定向区别" class="headerlink" title="转发和重定向区别"></a>转发和重定向区别</h2><p>第一点：转发浏览器发送一次请求，重定向浏览器发送两次请求（第一次访问servlet，第二次访问重定向到的地址</p><p>第二点：转发第二次发送的是服务器内部的跳转，所以地址栏还是第一次方式的请求的地址；重定向是浏览器发送两次请求，所以地址是重定向到的地址</p><p>第三点：转发可以获得请求域中的数据，重定向不可以，因为转发是一次请求，用到的request对象是同一个</p><p>能不能获取域对象中的数据，主要就是看使用的对象是不是同一个</p><p>第四点：转发能访问WEB-INF下的资源，重定向不可以，因为WEB-INF下的资源具有安全性，具有隐藏性，只能通过服务器内部来访问，不能通过浏览器访问</p><p>第五点：转发不能跨域（因为只能用内部资源），重定向可以跨域</p><h2 id="重定向视图的使用"><a href="#重定向视图的使用" class="headerlink" title="重定向视图的使用"></a>重定向视图的使用</h2><p>重定向可以改变地址栏中的地址，是相当于浏览器再一次发送请求去访问，那我们某一个业务逻辑操作成功之后，像是添加成功、修改、删除成功，和原来的请求就没有关系了，这个时候就需要重定向来跳转到下一个目录，如果用转发就会保留上一次请求的路径，所以在业务逻辑操作成功之后都应该通过重定向来实现路径跳转</p><h2 id="mvc注解驱动标签"><a href="#mvc注解驱动标签" class="headerlink" title="mvc注解驱动标签"></a>mvc注解驱动标签</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启mvc的注解驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><p>在EL表达式里面通过访问属性来访问，把get、set去掉，剩余部分的首字母变为小写</p><h2 id="过滤器顺序问题"><a href="#过滤器顺序问题" class="headerlink" title="过滤器顺序问题"></a>过滤器顺序问题</h2><p>设置编码之前不能获取任何的请求参数，只要获取，设置编码就没有任何效果了</p><h2 id="处理静态资源的问题"><a href="#处理静态资源的问题" class="headerlink" title="处理静态资源的问题"></a>处理静态资源的问题</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--开放对静态资源的访问 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--开启mvc注解驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>光加第一个：全是默认的defaultServlet处理的</p><p>不加第一个：都是DispatcherServlet处理的</p><p>加上两个：先由DispatcherServlet处理，处理不了的再defaultServlet处理</p><h2 id="根据重写servlet方法的问题引出"><a href="#根据重写servlet方法的问题引出" class="headerlink" title="根据重写servlet方法的问题引出"></a>根据重写servlet方法的问题引出</h2><p>filter没有扩展的类，我们可以给它创建一个，然后去重写它的三个方法，只需要重写初始化和销毁，因为这两个方法用不上，里面也不需要写啥代码，只需要把真正需要重写的doFilter方法设置为一个抽象方法，，那以后就不需要直接去实现filter接口了，只需要去继承重写</p><p>如果以后请求达不到自己的要求，咱们也可以通过自己的想法定制一个，然后通过过滤器给它换掉</p><h2 id="请求头的信息"><a href="#请求头的信息" class="headerlink" title="请求头的信息"></a>请求头的信息</h2><p>referer:”<a href="http://localhost:8080/springMVC/&quot;">http://localhost:8080/springMVC/&quot;</a></p><p>referer代表跳转过来的上一个地址</p><p>（比如删除完成之后再访问原来的页面，就可以利用这个）</p><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p>是一种数据交互格式</p><p>（微服务与微服务之间的数据交互用的就是json+http）</p><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置要下载方式以及下载文件的名字</span></span><br><span class="line">headers.add(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=1.jpg&quot;</span>);</span><br></pre></td></tr></table></figure><p>不管用那种文件下载方式，都要设置的东西</p><h2 id="要获得一个bean的方式"><a href="#要获得一个bean的方式" class="headerlink" title="要获得一个bean的方式"></a>要获得一个bean的方式</h2><p>要么根据id获取，要么根据类型获取</p><p>SpringMVC是通过id获取的</p><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>文件上传就是文件复制的过程，所以要先读再写，而我们在创建输出流的时候，有两个参数，其中一个是我们输出文件的位置，另一个是是否追加（append）默认是不追加也就是覆盖，不是覆盖文件，而是将文件中的内容覆盖掉了</p><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>&#x2F;**匹配所有请求</p><h1 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h1><ul><li><p><input checked="" disabled="" type="checkbox"> 最开始的工程500错误</p><p>原因：templates包名写的和配置里面的不一致</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 视图前缀 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis</title>
      <link href="/2022/10/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MyBatis/"/>
      <url>/2022/10/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MyBatis/</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="创建实体类对象属性与表字段对应"><a href="#创建实体类对象属性与表字段对应" class="headerlink" title="创建实体类对象属性与表字段对应"></a>创建实体类对象属性与表字段对应</h2><p>过程用的是反射，会把当前查询出来的字段名作为属性名来查找这个属性，并且为属性赋值</p><h2 id="MyBatis为什么要创建接口"><a href="#MyBatis为什么要创建接口" class="headerlink" title="MyBatis为什么要创建接口"></a>MyBatis为什么要创建接口</h2><p>因为mybatis中有面向接口编程的功能，每当我们去调用接口中的方法，它就会自动匹配一个sql语句，并去执行</p><h2 id="MyBatis面向接口编程的两个一致"><a href="#MyBatis面向接口编程的两个一致" class="headerlink" title="MyBatis面向接口编程的两个一致"></a>MyBatis面向接口编程的两个一致</h2><ol><li>映射文件的namespace要和mapper接口的全类名保持一致</li><li>映射文件中sql语句的id要和mapper接口中的方法名一致</li></ol><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>mybatis设置了默认的类型别名，官方文档中有说明</p><h2 id="map集合响应到浏览器"><a href="#map集合响应到浏览器" class="headerlink" title="map集合响应到浏览器"></a>map集合响应到浏览器</h2><p>对应的就是json对象</p><h3 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h3><p>需要从页面访问json对象，有各种键各种值，当前页面所需要的值不是从一张表中查询出来的，有可能从多张表中查询出来的，我们想通过一个sql语句或者通过一个sql语句查询出来后并没有相对应的实体对象，哪我们可以通过一个map对象获取相对应的结果，并且将map集合响应到浏览器</p><h2 id="各种查询功能"><a href="#各种查询功能" class="headerlink" title="各种查询功能"></a>各种查询功能</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mybatis的各种查询功能</span></span><br><span class="line"><span class="comment"> * 1、查询结果只有一条，能通过实体类接收或者List集合接收,</span></span><br><span class="line"><span class="comment"> * 也可以通过map集合接收：&#123;password=123456, sex=男, id=3, age=23, email=123456@qq.com, username=admin&#125;</span></span><br><span class="line"><span class="comment"> * 2、有多条，不能通过实体类接收，可以通过实体类型的List集合接收，可以通过map类型的List集合接收</span></span><br><span class="line"><span class="comment"> * 可以在mapper接口的方法上添加<span class="doctag">@MapKey</span>注解，此时就可以将每条数据转换的map集合作为值，以某个字段的值作为键，放在同一个map集合中</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="获取添加功能自增的主键"><a href="#获取添加功能自增的主键" class="headerlink" title="获取添加功能自增的主键"></a>获取添加功能自增的主键</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    void insertUser(User user);</span></span><br><span class="line"><span class="comment">         useGeneratedKeys:设置当前标签中的sql使用了自增的主键</span></span><br><span class="line"><span class="comment">         keyProperty:将自增的主键的值赋值给传输到映射文件中参数的某个属性</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><h2 id="解决字段名和属性名不一致的情况"><a href="#解决字段名和属性名不一致的情况" class="headerlink" title="解决字段名和属性名不一致的情况"></a>解决字段名和属性名不一致的情况</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决字段名和属性名不一致的情况</span></span><br><span class="line"><span class="comment"> * a&gt;为字段起别名，保持和属性名的一致</span></span><br><span class="line"><span class="comment"> * b&gt;设置全局配置，将下划线自动映射为驼峰: &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;</span></span><br><span class="line"><span class="comment"> * c&gt;通过resultMap设置自定义的映射关系</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="处理多对一映射关系"><a href="#处理多对一映射关系" class="headerlink" title="处理多对一映射关系"></a>处理多对一映射关系</h2><ol><li><p>级联属性赋值</p></li><li><p>association来实现</p><p>association：处理多对一的映射关系<br>property:需要处理多对一映射关系的属性名<br>javaType：该属性的类型</p></li><li><p>分布查询</p></li></ol><h2 id="传输的是一个数组时"><a href="#传输的是一个数组时" class="headerlink" title="传输的是一个数组时"></a>传输的是一个数组时</h2><p> Cause: org.apache.ibatis.binding.BindingException: Parameter ‘eids’ not found. Available parameters are [array, arg0]</p><p>当我们传输过来一个数组时，数组这个参数的访问也是固定的，mybatis会将它放在map里面，以array为键，以数组为值，以arg0为键，以数组为值，那么我们就要按照mybatis规定的方式访问</p><p>既然mybatis将它放到map中，那么我们也可以通过命名参数@Param来规定访问方式</p><h3 id="建议："><a href="#建议：" class="headerlink" title="建议："></a>建议：</h3><p>除了实体类对象和map对象，其他的方式都加上@Param，就可以以指定的方式访问了</p><h2 id="处理模糊查询"><a href="#处理模糊查询" class="headerlink" title="处理模糊查询"></a>处理模糊查询</h2><p>用#{}获取参数值的时候，在真正去执行的sql语句中，#{}会被问号代替，因为当前用的是模糊查询，所以#{}需要在一对单引号中，单引号在sql中表示的是字符串，那么当用#{}获取参数值，并且在执行的过程中用？代替#{}的时候，？就存在于单引号里边，那么现在？就属于字符串的一部分，它不会被解析成占位符，会被当成字符串的一部分来解析，如果这时候赋值就会报错</p><p>解决方案：</p><ul><li>使用${}</li><li>字符串拼接</li><li>用双引号拼接”%”#{username}”%”（最常用的方式）</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis6</title>
      <link href="/2022/10/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis6/"/>
      <url>/2022/10/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis6/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis6"><a href="#Redis6" class="headerlink" title="Redis6"></a>Redis6</h1><h2 id="nosql数据库"><a href="#nosql数据库" class="headerlink" title="nosql数据库"></a>nosql数据库</h2><h3 id="用nosql的好处："><a href="#用nosql的好处：" class="headerlink" title="用nosql的好处："></a>用nosql的好处：</h3><ul><li>不需要经过io操作，数据可以完全存到内存中，存到内存中读的速度更快</li><li>能直接作为缓存使用，提高访问速度，减小io的读操作</li></ul><h3 id="存储方式："><a href="#存储方式：" class="headerlink" title="存储方式："></a>存储方式：</h3><p>不依赖业务逻辑方式存储，而以简单的key-value模式存储，因此大大增加了数据库的扩展能力</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="一、启动"><a href="#一、启动" class="headerlink" title="一、启动"></a>一、启动</h3><p>刚上手使用Redis时，很容易遇到的问题就是Could not connect to Redis at 127.0.0.1:6379: Connection refused</p><p>解决方法：1、先开启服务端 </p><p>​                           redis-server &#x2F;etc&#x2F;redis.conf</p><p>​                    2、再去连接客户端</p><p>​                           &#x2F;usr&#x2F;local&#x2F;bin&#x2F;redis-cli</p><h3 id="二、技术"><a href="#二、技术" class="headerlink" title="二、技术"></a>二、技术</h3><p>单线程+多路IO复用</p><h3 id="三、常用的数据类型操作"><a href="#三、常用的数据类型操作" class="headerlink" title="三、常用的数据类型操作"></a>三、常用的数据类型操作</h3><h4 id="1-五大基本数据类型"><a href="#1-五大基本数据类型" class="headerlink" title="1.五大基本数据类型"></a>1.五大基本数据类型</h4><ul><li><h4 id="Redis字符串（String）"><a href="#Redis字符串（String）" class="headerlink" title="Redis字符串（String）"></a>Redis字符串（String）</h4><h5 id="1-二进制安全"><a href="#1-二进制安全" class="headerlink" title="1.二进制安全"></a>1.二进制安全</h5><p>String类型是二进制安全的</p><p>只要内容能用字符串表示那都可以存到里面去，比如图片或者序列化对象</p><h5 id="2-原子性"><a href="#2-原子性" class="headerlink" title="2.原子性"></a>2.原子性</h5><p>Redis操作是原子操作，不会被线程调度机制打断的操作</p><h6 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h6><h5 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3.数据结构"></a>3.数据结构</h5><p>内部结果实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配</p></li><li><h4 id="Redis列表（List）"><a href="#Redis列表（List）" class="headerlink" title="Redis列表（List）"></a>Redis列表（List）</h4><p>底层数据结果是快速链表（quickList）</p><p>再列表元素比较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表</p><p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存</p><p>数据量比较多的时候才会改成quickList</p></li><li><h4 id="Redis集合（Set）"><a href="#Redis集合（Set）" class="headerlink" title="Redis集合（Set）"></a>Redis集合（Set）</h4><p>底层是一个value值为null的hash表</p><p>所有value都指向同一个内部值</p></li><li><h4 id="Redis哈希（Hash）"><a href="#Redis哈希（Hash）" class="headerlink" title="Redis哈希（Hash）"></a>Redis哈希（Hash）</h4><p>是一个键值对集合</p><p>特别适合于存储对象，类似java里面的Map&lt;String,Object&gt;</p><p>对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable</p></li><li><h4 id="Redis有序集合Zset"><a href="#Redis有序集合Zset" class="headerlink" title="Redis有序集合Zset"></a>Redis有序集合Zset</h4><p>底层使用了两个数据结构</p><ol><li>hash</li><li>跳跃表</li></ol></li></ul><h4 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2.配置文件"></a>2.配置文件</h4><h4 id="3-发送和订阅"><a href="#3-发送和订阅" class="headerlink" title="3.发送和订阅"></a>3.发送和订阅</h4><h4 id="4-新数据类型"><a href="#4-新数据类型" class="headerlink" title="4.新数据类型"></a>4.新数据类型</h4><h5 id="（1）BitMaps（网站独立访问用户）"><a href="#（1）BitMaps（网站独立访问用户）" class="headerlink" title="（1）BitMaps（网站独立访问用户）"></a>（1）BitMaps（网站独立访问用户）</h5><p>bitmaps和set进行对比：网站每天独立访问用户很少的话用</p><p>set，很多的话用bitmaps</p><h5 id="（2）HyperLogLog（基数问题）"><a href="#（2）HyperLogLog（基数问题）" class="headerlink" title="（2）HyperLogLog（基数问题）"></a>（2）HyperLogLog（基数问题）</h5><h5 id="（3）Geospatial（地理信息的操作）"><a href="#（3）Geospatial（地理信息的操作）" class="headerlink" title="（3）Geospatial（地理信息的操作）"></a>（3）Geospatial（地理信息的操作）</h5><h4 id="5-jedis"><a href="#5-jedis" class="headerlink" title="5.jedis"></a>5.jedis</h4><h5 id="（1）注意事项：要配置文件内容，要关防火墙"><a href="#（1）注意事项：要配置文件内容，要关防火墙" class="headerlink" title="（1）注意事项：要配置文件内容，要关防火墙"></a>（1）注意事项：要配置文件内容，要关防火墙</h5><h5 id="（2）实例：验证码"><a href="#（2）实例：验证码" class="headerlink" title="（2）实例：验证码"></a>（2）实例：验证码</h5><ol><li><p>生成随机6位数字验证码</p><p>Random</p></li><li><p>验证码两分钟之内有效</p><p>放到redis，设置过期时间120s</p></li><li><p>判断验证码是否一致</p><p>从redis获取验证码和输入的验证码进行比较</p></li><li><p>每个手机每天只能发送三次验证码</p><p>incr每次发送之后+1</p><p>大于2的时候，提交不能发送</p></li></ol><h3 id="四、事务和锁机制"><a href="#四、事务和锁机制" class="headerlink" title="四、事务和锁机制"></a>四、事务和锁机制</h3><h5 id="1-主要作用"><a href="#1-主要作用" class="headerlink" title="1.主要作用"></a>1.主要作用</h5><p>串联多个命令防止别的命令插队</p><h5 id="2-基本操作"><a href="#2-基本操作" class="headerlink" title="2.基本操作"></a>2.基本操作</h5><p>组队中出现错误，都不会执行</p><p>组队成功，执行中出现错误，只有错误命令不会执行</p><h5 id="3-事务冲突问题"><a href="#3-事务冲突问题" class="headerlink" title="3.事务冲突问题"></a>3.事务冲突问题</h5><ul><li><p>悲观锁</p><p>每次拿数据都认为别人会修改，都会上锁</p></li><li><p>乐观锁</p><p>每次拿数据都认为别人不会修改，不会上锁，但是在更新的时候会判断以下在此期间别人有没有去更新这个数据，可以使用版本号等机制</p></li></ul><h5 id="4-Reids事务的特性"><a href="#4-Reids事务的特性" class="headerlink" title="4.Reids事务的特性"></a>4.Reids事务的特性</h5><ul><li>单独的隔离操作</li><li>没有隔离级别的概念</li><li>不保证原子性</li></ul><h5 id="5-秒杀案例"><a href="#5-秒杀案例" class="headerlink" title="5.秒杀案例"></a>5.秒杀案例</h5><h6 id="秒杀过程："><a href="#秒杀过程：" class="headerlink" title="秒杀过程："></a>秒杀过程：</h6><p>1、uid和prodid非空判断</p><p>2、连接redis</p><p>3、拼接key</p><p>4、获取库存，如果库存null，秒杀还没开始</p><p>5、判断用户是否重复做秒杀操作</p><p>6、判断如果商品数量，库存数量小于1，秒杀结束</p><p>7、秒杀过程：</p><p>​      库存减一</p><p>​      把秒杀用户添加清单里面</p><h6 id="超卖问题："><a href="#超卖问题：" class="headerlink" title="超卖问题："></a>超卖问题：</h6><p>利用乐观锁方式，每次判断版本号是否一致</p><p>&#x2F;&#x2F;监视库存</p><h6 id="超时问题："><a href="#超时问题：" class="headerlink" title="超时问题："></a>超时问题：</h6><p>连接池解决</p><h6 id="库存遗留问题："><a href="#库存遗留问题：" class="headerlink" title="库存遗留问题："></a>库存遗留问题：</h6><p>lua脚本</p><p>将复杂或多步的redis操作，写为一个脚本，一次提交给redis执行，减少反复连接redis的次数，提升性能</p><h3 id="五、持久化操作"><a href="#五、持久化操作" class="headerlink" title="五、持久化操作"></a>五、持久化操作</h3><p>什么叫持久化：redis数据写到硬盘中</p><h4 id="一、持久化操作-RDB"><a href="#一、持久化操作-RDB" class="headerlink" title="一、持久化操作-RDB"></a>一、持久化操作-RDB</h4><p>通过一个fork的子进程，建一个临时文件，再替换那个持久化文件，过程中用的技术叫写实复制技术。</p><h4 id="二、持久化操作-AOF"><a href="#二、持久化操作-AOF" class="headerlink" title="二、持久化操作-AOF"></a>二、持久化操作-AOF</h4><p>以日志的形式来记录每个写操作（增量保存），将redis执行过的所有写指令记录下来，只许追加文件但不可以改写文件</p><p>AOF和RDB同时开启，系统默认取AOF的数据</p><p>重写操作</p><h4 id="三、用哪个好"><a href="#三、用哪个好" class="headerlink" title="三、用哪个好"></a>三、用哪个好</h4><p>官方推荐两个都使用</p><p>如果对数据不敏感，可以单独选用RDB</p><p>不建议单独用AOF，因为可能会出现bug</p><p>如果只是做纯内存缓存，可以都不用</p><h3 id="六、主从复制"><a href="#六、主从复制" class="headerlink" title="六、主从复制"></a>六、主从复制</h3><h4 id="1-搭建一主多从"><a href="#1-搭建一主多从" class="headerlink" title="1.搭建一主多从"></a>1.搭建一主多从</h4><ol><li>创建&#x2F;myredis文件夹</li><li>复制redis.conf配置文件到文件夹中</li><li>配置一主多从，创建三个配置文件</li><li>在三个文件中写入内容</li><li>启动三个redis服务<ul><li>查看当前主机运行情况</li><li>在从机上执行slaveof 主机ip 端口号</li></ul></li></ol><h4 id="2-复制原理和一主二仆"><a href="#2-复制原理和一主二仆" class="headerlink" title="2.复制原理和一主二仆"></a>2.复制原理和一主二仆</h4><p>特点：</p><ul><li>当从服务器挂掉了，在启动之后，并不能自动加入到主从里面来，要自己重新加入。</li><li>在加入的时候，它会把主服务器中的数据从头开始复制</li><li>当主服务器挂掉后，从服务器不会上位，重启之后依旧是主服务器</li></ul><p>复制原理：</p><ol><li>当从连接上主之后，从服务器向主服务器发送进行数据同步</li><li>主接到从发送过来同步消息，将主服务器数据进行持久化，rdb文件，把rdb文件发送到从服务器，从服务器拿到rdb进行读取</li><li>每次主服务器进行写操作后，和从服务器进行数据同步</li></ol><h4 id="3-薪火相传和反客为主"><a href="#3-薪火相传和反客为主" class="headerlink" title="3.薪火相传和反客为主"></a>3.薪火相传和反客为主</h4><p>slaveof no one 将从机变为主机</p><h4 id="4-哨兵模式"><a href="#4-哨兵模式" class="headerlink" title="4.哨兵模式"></a>4.哨兵模式</h4><h3 id="七、Redis集群"><a href="#七、Redis集群" class="headerlink" title="七、Redis集群"></a>七、Redis集群</h3><p>容量不够，redis如何进行扩容？</p><p>并发写操作，redis如何分离？</p><p>另外，主从模式、薪火相传模式。主机宕机，导致IP地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息</p><p>之前通过代理主机解决，现在用无中心化集群配置</p><p>redis-cli –cluster create –cluster-replicas 1 192.168.29.129:6379 192.168.29.129:6380 192.168.29.129:6381 192.168.29.129:6389 192.168.29.129:6390 192.168.29.129:6391</p><p>16384 slots covered.</p><h4 id="分配原则"><a href="#分配原则" class="headerlink" title="分配原则"></a>分配原则</h4><p>分配原则尽量保证每个主数据库运行在不同的ip地址，每个从库和主库不在一个ip地址上</p><p>redis集群 16383个插槽</p><h4 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h4><p>主机挂掉，从机代替称为主机，主机恢复后变为从机</p><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>实现扩容</p><p>分摊压力</p><p>无中心配置相对简单</p><h3 id="八、应用问题解决"><a href="#八、应用问题解决" class="headerlink" title="八、应用问题解决"></a>八、应用问题解决</h3><h4 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1.缓存穿透"></a>1.缓存穿透</h4><p>解决方案：</p><p>（1）对空值缓存</p><p>（2）白名单（bitmaps）</p><p>（3）布隆过滤器</p><p>（4）实时监控</p><h4 id="2-缓存击穿"><a href="#2-缓存击穿" class="headerlink" title="2.缓存击穿"></a>2.缓存击穿</h4><p>解决方案：</p><p>（1）预先设置热门数据</p><p>（2）实时调整</p><p>（3）使用锁</p><h4 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3.缓存雪崩"></a>3.缓存雪崩</h4><p>（1）构建多级缓存架构</p><p>（2）使用锁或者队列</p><p>（3）设置过期标志更新缓存</p><p>（4）让缓存失效时间分散开</p><h4 id="4-分布式锁"><a href="#4-分布式锁" class="headerlink" title="4.分布式锁"></a>4.分布式锁</h4><p>设置锁和过期时间</p><p>1、使用setnx上锁，通过del释放锁</p><p>2、锁一直没有释放，设置key过期时间，自动释放</p><p> expire usrs 10</p><p>3、上锁之后突然出现异常，无法设置过期时间</p><p>上锁的同时设置过期时间</p><p>set users 10 nx ex 12</p><p>4、UUID防止误删</p><p>lus脚本：LUA脚本保证删除的原子性</p><h3 id="九、新功能"><a href="#九、新功能" class="headerlink" title="九、新功能"></a>九、新功能</h3><h4 id="1-ACL"><a href="#1-ACL" class="headerlink" title="1.ACL"></a>1.ACL</h4><h4 id="2-IO多线程"><a href="#2-IO多线程" class="headerlink" title="2.IO多线程"></a>2.IO多线程</h4><p>多线程部分只是用来处理网络数据的读写和协议解析</p><h4 id="3-工具支持Cluster"><a href="#3-工具支持Cluster" class="headerlink" title="3.工具支持Cluster"></a>3.工具支持Cluster</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>wifi消失</title>
      <link href="/2022/10/11/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E5%B0%8F%E9%97%AE%E9%A2%98/WiFi%E6%B6%88%E5%A4%B1/"/>
      <url>/2022/10/11/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E5%B0%8F%E9%97%AE%E9%A2%98/WiFi%E6%B6%88%E5%A4%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览网页的时候突然断网，发现WiFi消失了"><a href="#浏览网页的时候突然断网，发现WiFi消失了" class="headerlink" title="浏览网页的时候突然断网，发现WiFi消失了"></a>浏览网页的时候突然断网，发现WiFi消失了</h1><h2 id="现象描述"><a href="#现象描述" class="headerlink" title="现象描述"></a>现象描述</h2><p>没有WiFi选项 wlan也消失 网络和Internet设置里面也没有WiFi选项<br>驱动里面有一项为黄色感叹号，属性提示为，该驱动有问题，被停用<br><img src="/./img/wifi%E6%B6%88%E5%A4%B1.png" alt="出现感叹号的地方"></p><h2 id="尝试解决办法"><a href="#尝试解决办法" class="headerlink" title="尝试解决办法"></a>尝试解决办法</h2><ol><li>把网络适配器重新启动（不行）</li><li>从别的电脑下载驱动精灵再安装到本电脑上（不行）</li><li>从手机上下载网卡驱动再安装到电脑上（不行）</li></ol><h2 id="最后解决办法"><a href="#最后解决办法" class="headerlink" title="最后解决办法"></a>最后解决办法</h2><p>删掉黄色感叹号的驱动</p><h2 id="出现问题的原因"><a href="#出现问题的原因" class="headerlink" title="出现问题的原因"></a>出现问题的原因</h2><p>网卡驱动冲突（不适配）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多用户通信系统</title>
      <link href="/2022/10/11/%E9%A1%B9%E7%9B%AE/%E5%A4%9A%E7%94%A8%E6%88%B7%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/10/11/%E9%A1%B9%E7%9B%AE/%E5%A4%9A%E7%94%A8%E6%88%B7%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="多用户通信系统"><a href="#多用户通信系统" class="headerlink" title="多用户通信系统"></a>多用户通信系统</h3><p><img src="/./img/%E5%A4%9A%E7%94%A8%E6%88%B7%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F.png" alt="整体分析"></p><ul><li><p>需求分析</p><ol><li>用户登录</li><li>拉取在线用户列表</li><li>无异常退出（客户端、服务端）</li><li>私聊</li><li>发文件</li><li>服务器推送新闻</li></ol></li><li><p>一些思路：有些需要繁琐验证的地方可以先留着不写，先把整个逻辑打通</p><p>因为消息的种类有很多，所有设置一个MessageType的接口来设置消息种类</p><p>发文件的方法，要增加message的种类，添加传输文件需要的属性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进行扩展 和文件相关的成员</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] fileBytes;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">fileLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> String dest;<span class="comment">//将文件传输到哪里</span></span><br><span class="line"><span class="keyword">private</span> String src;<span class="comment">//源文件路径    </span></span><br></pre></td></tr></table></figure><p>服务器推送消息：</p><p>在服务器端单独写一个线程</p></li><li><p>一些巧妙地思想：</p><p>验证用户是否有效的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkUser</span><span class="params">(String userId,String pwd)</span>&#123;</span><br><span class="line">       <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> validUsers.get(userId);</span><br><span class="line">       <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;<span class="comment">//如果user为空，说明userId不存在集合中</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(!user.getPasswd().equals(pwd))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>集合的运用以及过关斩将的判断</p><p>向服务端请求在线用户列表发送Message的时候应该得到当前线程的socket 对应的ObjectOutputStream对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">先从管理线程的集合中，通过userId，得到这个线程</span><br><span class="line">然后得到当前线程的socket对应的ObjectOutputStream对象</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>        (ManageClientConnectServerThread.getClientConnectServerThread(u.getUserId())                                                 .getSocket().getOutputStream());</span><br></pre></td></tr></table></figure></li><li><p>一些选择：</p><p>存放用户时：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//HashMap 没有处理线程安全，因此在多线程情况下是不安全的</span><br><span class="line">//ConcurrentHashMap 处理的线程安全，即线程同步处理，在多线程情况下是安全的</span><br></pre></td></tr></table></figure></li><li><p>一些问题：</p><p>退出异常的情况，为啥选了退出选项之后还是没有退出程序呢？（线程问题）</p></li><li><p>一些自己写的方法</p><p>私聊：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//私聊（客户端）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">communicate</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入想聊天的用户号（在线）：&quot;</span>);</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">        message.setMesType(MessageType.MESSAGE_COMM_MES);</span><br><span class="line">        message.setSender(u.getUserId());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span></span><br><span class="line">                    (ManageClientConnectServerThread.getClientConnectServerThread(u.getUserId()).getSocket().getOutputStream());</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入想说的话&quot;</span>);</span><br><span class="line">         <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">         message.setContent(userId + <span class="string">&quot; &quot;</span> + word);</span><br><span class="line">         oos.writeObject(message);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//(服务端)</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(m.getMesType().equals(MessageType.MESSAGE_COMM_MES))&#123;</span><br><span class="line">    String[] s = m.getContent().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ManageClientThreads.getServerConnectClientThread(s[<span class="number">0</span>]) != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">        message.setContent(m.getSender() + <span class="string">&quot;对&quot;</span> + s[<span class="number">0</span>] + <span class="string">&quot;说&quot;</span> + s[<span class="number">1</span>]);</span><br><span class="line">        message.setMesType(MessageType.MESSAGE_COMM_MES);</span><br><span class="line"></span><br><span class="line">        message.setGetter(m.getSender());</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(socket.getOutputStream());</span><br><span class="line">        oos.writeObject(message);</span><br><span class="line">        oos.flush();</span><br><span class="line"></span><br><span class="line">        <span class="type">Message</span> <span class="variable">message2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">        message2.setContent(m.getSender() + <span class="string">&quot;对&quot;</span> + s[<span class="number">0</span>] + <span class="string">&quot;说&quot;</span> + s[<span class="number">1</span>]);</span><br><span class="line">        message2.setMesType(MessageType.MESSAGE_COMM_MES);</span><br><span class="line">        message2.setGetter(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(ManageClientThreads.getServerConnectClientThread(s[<span class="number">0</span>])</span><br><span class="line">                .socket.getOutputStream());</span><br><span class="line">        oos2.writeObject(message2);</span><br><span class="line">        oos2.flush();</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">        message.setGetter(m.getSender());</span><br><span class="line">        message.setContent(<span class="string">&quot;用户不在线或不存在&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(socket.getOutputStream());</span><br><span class="line">        oos2.writeObject(message);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>老师的思路：创建一个专门类，提供和消息相关的服务方法</p></li><li><p>一些警告</p><p>Iterator类的next( )方法在同一循环中不能出现两次，不然会报以下异常</p><p>NoSuchElementException：没有这样的元素异常。</p><p>这个异常应该是说定位不到这样的元素，也就是找不到这样的元素。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础复习</title>
      <link href="/2022/10/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"/>
      <url>/2022/10/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础复习"><a href="#Java基础复习" class="headerlink" title="Java基础复习"></a>Java基础复习</h1><h2 id="一、继承本质详解"><a href="#一、继承本质详解" class="headerlink" title="一、继承本质详解"></a>一、继承本质详解</h2><h2 id="二、super和this的比较"><a href="#二、super和this的比较" class="headerlink" title="二、super和this的比较"></a>二、super和this的比较</h2><table><thead><tr><th>no.</th><th>区别点</th><th>this</th><th>super</th></tr></thead><tbody><tr><td>1</td><td>访问属性</td><td>访问本类中的属性，如果本类中没有此属性则从父类中继续查找</td><td>从父类开始查找属性</td></tr><tr><td>2</td><td>调用方法</td><td>访问本类中的方法，如果本类中没有此方法则从父类中继续查找</td><td>从父类开始查找方法</td></tr><tr><td>3</td><td>调用构造器</td><td>调用本类构造器，必须放在构造器的首行</td><td>调用父类构造器，必须放在子类构造器的首行</td></tr><tr><td>4</td><td>特殊</td><td>表示当前的对象</td><td>子类中访问父类对象</td></tr></tbody></table><h2 id="三、重写和重载的区别"><a href="#三、重写和重载的区别" class="headerlink" title="三、重写和重载的区别"></a>三、重写和重载的区别</h2><table><thead><tr><th>名称</th><th>发生范围</th><th>方法名</th><th>参数列表</th><th>返回类型</th><th>修饰符</th></tr></thead><tbody><tr><td>重载（overload）</td><td>本类</td><td>一样</td><td>类型、个数或顺序有一个不同</td><td>无要求</td><td>无要求</td></tr><tr><td>重写（override）</td><td>父子类</td><td>一样</td><td>相同</td><td>子类重写的方法返回类型和父类的返回类型一致或者是其子类</td><td>子类重写方法不能缩小父类方法的访问范围</td></tr></tbody></table><h2 id="四、多态"><a href="#四、多态" class="headerlink" title="四、多态"></a>四、多态</h2><h3 id="1-方法的多态"><a href="#1-方法的多态" class="headerlink" title="1.方法的多态"></a>1.方法的多态</h3><p>重写和重载体现多态</p><h3 id="2-对象的多态"><a href="#2-对象的多态" class="headerlink" title="2.对象的多态"></a>2.对象的多态</h3><ol><li>一个对象的编译类型和运行类型可以不一致</li><li>编译类型在定义对象的时候就确定了，不能改变</li><li>运行类型是可以变化的</li><li>编译类型看定义时&#x3D;号的左边，运行类型看&#x3D;号的右边</li></ol><p><strong>向上转型</strong>：父类的引用指向子类的对象</p><p>​                   可以调用父类中所有的成员（须遵循访问权限）</p><p>​                   但是不能调用子类的特有成员</p><p>​                   因为在编译阶段能调用哪些成员，是由编译类型决定的</p><p>​                   最终运行效果看子类的具体实现</p><p><strong>向下转型</strong>：语法：子类类型 引用名 &#x3D; （子类类型 ）父类引用</p><p><strong>属性</strong>没有重写之说，属性的值看编译类型</p><p>instanceOf 比较操作符，用于判断对象的<strong>运行类型</strong>是否为XX类型或XX类型的子类型</p><h3 id="3-Java的动态绑定机制"><a href="#3-Java的动态绑定机制" class="headerlink" title="3.Java的动态绑定机制"></a>3.Java的动态绑定机制</h3><ul><li>当调用<strong>对象方法</strong>的时候，该方法会和该对象的<strong>内存地址&#x2F;运行类</strong>型绑定</li><li>当调用<strong>对象属性</strong>的时候，没有动态绑定机制，<strong>哪里声明，哪里使用</strong></li></ul><h3 id="4-多态的应用"><a href="#4-多态的应用" class="headerlink" title="4.多态的应用"></a>4.多态的应用</h3><ul><li>多态数组</li><li>多态参数</li></ul><h2 id="五、Object类详解"><a href="#五、Object类详解" class="headerlink" title="五、Object类详解"></a>五、Object类详解</h2><h3 id="1-x3D-x3D-比较运算符"><a href="#1-x3D-x3D-比较运算符" class="headerlink" title="1.&#x3D;&#x3D;比较运算符"></a>1.&#x3D;&#x3D;比较运算符</h3><ul><li>既可以判断基本类型、又可以判断引用类型</li><li>如果判断基本类型、判断值是否相等</li><li>如果判断引用类型，判断地址是否相等，即判断是否是同一个对象</li></ul><h3 id="2-equals方法"><a href="#2-equals方法" class="headerlink" title="2.equals方法"></a>2.equals方法</h3><ul><li>equals是object类中的方法，只能判断引用类型</li><li>默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等。比如Integer、String</li></ul><p>Object的equals</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String的equals</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jdk源码，Object的equals方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Compares this string to the specified object.  The result is &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * true&#125; if and only if the argument is not &#123;<span class="doctag">@code</span> null&#125; and is a &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * String&#125; object that represents the same sequence of characters as this</span></span><br><span class="line"><span class="comment"> * object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  anObject</span></span><br><span class="line"><span class="comment"> *         The object to compare this &#123;<span class="doctag">@code</span> String&#125; against</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if the given object represents a &#123;<span class="doctag">@code</span> String&#125;</span></span><br><span class="line"><span class="comment"> *          equivalent to this string, &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>  #compareTo(String)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>  #equalsIgnoreCase(String)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;<span class="comment">//如果是同一个对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;<span class="comment">//判断类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;<span class="comment">//向下转型</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;<span class="comment">//如果长度相同</span></span><br><span class="line">            <span class="type">char</span> v1[] = value;</span><br><span class="line">            <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;<span class="comment">//一个一个比较字符</span></span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//如果两个字符串的所以字符都相等，则返回true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果比较的不是字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Integer的equals</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">        <span class="keyword">return</span> value == ((Integer)obj).intValue();<span class="comment">//如果当前Integer的值等于传进来的对象的值，如果相等就返回真</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-hashCode方法"><a href="#3-hashCode方法" class="headerlink" title="3.hashCode方法"></a>3.hashCode方法</h3><ol><li>提高具有哈希结构的容器的效率</li><li>两个引用，如果指向是同一个对象，那么哈希值肯定是一样的</li><li>两个引用，如果指向是不同对象，那么哈希值是不一样的（小概率一样）</li><li>哈希值主要根据地址号来的，不能完全将哈希值等同于地址</li><li>重写方法</li></ol><h3 id="4-toString方法"><a href="#4-toString方法" class="headerlink" title="4.toString方法"></a>4.toString方法</h3><ul><li><p>Object的toString方法源码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//getClass().getName()类的全类名（包名加类名）</span></span><br><span class="line">  <span class="comment">//Integer.toHexString(hashCode())将对象的hashCode值转成16进制</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span>+Integer.toHexString(hashCode());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>重写后一般是把对象的属性信息输出</p></li><li><p>当我们直接输出一个对象的时候，toString方法会被默认的调用</p></li></ul><h3 id="5-finalize方法"><a href="#5-finalize方法" class="headerlink" title="5.finalize方法"></a>5.finalize方法</h3><ul><li><p>当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一个释放资源的操作（如数据库连接、或者打开文件）</p></li><li><p>什么时候被回收：当某个对象没有任何引用的时候，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收器机制来销毁该对象，在销毁该对象前，会先调用finalize方法</p></li><li><p>垃圾回收机制的调用，是由系统来决定的（即有自己的GC算法），也可以通过System.gc()主动触发垃圾回收机制</p></li></ul><h2 id="六、常用类"><a href="#六、常用类" class="headerlink" title="六、常用类"></a>六、常用类</h2><h3 id="一、StringBuffer"><a href="#一、StringBuffer" class="headerlink" title="一、StringBuffer"></a>一、StringBuffer</h3><h4 id="1-StringBuffer结构剖析"><a href="#1-StringBuffer结构剖析" class="headerlink" title="1.StringBuffer结构剖析"></a>1.StringBuffer结构剖析</h4><ol><li>StringBuffer的直接父类是AbstractStringBuilder</li><li>实现了Serialzable，即StringBuffer的对象可以串行化</li><li>在父类中，AbstractStringBuilder有属性char[] value，不是final,该value数组存放字符串内容</li><li>StringBuffer是final类，不能被继承</li><li>StringBuffer字符内容是存在char[] value，所以变化（增加&#x2F;删除）时不用每次都更换地址（即不是每次创建新对象）。所以效率高于String</li></ol><h4 id="2-StringBuffer转换"><a href="#2-StringBuffer转换" class="headerlink" title="2.StringBuffer转换"></a>2.StringBuffer转换</h4><ol><li>String-&gt;StringBuffer<ul><li>使用构造器</li><li>使用append方法</li></ul></li><li>StringBuffer-&gt;<ul><li>使用使用StringBuffer提供的toString方法</li><li>使用构造器d’r’r’r’r’r’r’r’r’d’r’g’g’g’g’g’g’g’g</li></ul></li></ol><h4 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3.常用方法"></a>3.常用方法</h4><ol><li>增 append</li><li>删 delete(start,end)</li><li>改 replace(start,end,string)&#x2F;&#x2F;将start—end间的内容替换掉，不含end</li><li>查 indexOf&#x2F;&#x2F;查找子串在字符串第一次出现的索引，如果找不到返回-1</li><li>插 insert</li><li>获取长度 length</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>；</span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line">sb.append(str);</span><br></pre></td></tr></table></figure><p>源码：</p><p>底层调用的是AbstractStringBuilder的appendNull</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AbstractStringBuilder <span class="title function_">appendNull</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> count;</span><br><span class="line">    ensureCapacityInternal(c + <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">char</span>[] value = <span class="built_in">this</span>.value;</span><br><span class="line">    value[c++] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">    value[c++] = <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">    value[c++] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">    value[c++] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">    count = c;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);</span><br></pre></td></tr></table></figure><p>底层源码：super(str.length()+16);</p><p>会抛出空指针异常</p><h3 id="二、StringBuilder"><a href="#二、StringBuilder" class="headerlink" title="二、StringBuilder"></a>二、StringBuilder</h3><h4 id="1-StringBuilder结构剖析"><a href="#1-StringBuilder结构剖析" class="headerlink" title="1.StringBuilder结构剖析"></a>1.StringBuilder结构剖析</h4><ol><li>继承AbstractStringBuilder</li><li>实现了Serialzable，StringBuilder的对象可以串行化</li><li>是final类，不能被继承</li><li>StringBuilder对象的字符序列仍然是存放在其父类AbstractStringBuilder的char[] value，因此，字符序列在堆中</li><li>StringBuilder的方法，没有做互斥处理，即没有synchronized关键字，因此在单线程的情况下使用StringBuilder</li></ol><h3 id="三、String、StringBuffer、StringBuilder"><a href="#三、String、StringBuffer、StringBuilder" class="headerlink" title="三、String、StringBuffer、StringBuilder"></a>三、String、StringBuffer、StringBuilder</h3><ol><li><p>StringBuffer和StringBuilder非常相似，均代表可变的字符序列，而且方法也一样</p></li><li><p>String：不可变的字符序列，效率低，但是复用率高</p></li><li><p>StringBuffer：可变的字符序列，效率较高（增删）线程安全</p></li><li><p>StringBuilder：可变字符序列、效率最高、线程不安全</p></li><li><p>String使用注意说明：</p><p>如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能&#x3D;》j结论：如果我们对字符串做大量修改，不要使用String</p><p>如果字符串很少修改，被多个对象引用，使用String，比如配置信息等</p></li></ol><h3 id="四、Math类"><a href="#四、Math类" class="headerlink" title="四、Math类"></a>四、Math类</h3><ol><li>abs 绝对值</li><li>pow 求幂</li><li>ceil 向上取整</li><li>floor 向下取整</li><li>round 四舍五入</li><li>sqrt 求开方</li><li>random 随机数</li><li>max，min 返回最大值和最小值</li></ol><h3 id="五、Arrays"><a href="#五、Arrays" class="headerlink" title="五、Arrays"></a>五、Arrays</h3><ol><li><p>直接使用Arrays.toString方法，显示数组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">iMax</span> <span class="operator">=</span> a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (iMax == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    b.append(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">        b.append(String.valueOf(a[i]));</span><br><span class="line">        <span class="keyword">if</span> (i == iMax)</span><br><span class="line">            <span class="keyword">return</span> b.append(<span class="string">&#x27;]&#x27;</span>).toString();</span><br><span class="line">        b.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>sort方法</p><ul><li><p>进行排序</p></li><li><p>默认是从小到大</p></li><li><p>sort重载的，也可以通过传入一个接口 Comparator 实现定制排序</p></li><li><p>调用定制排序时，传入两个参数 ①排序的数组 ②实现了Comparator 接口的匿名内部类，要求实现compare方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">     </span><br></pre></td></tr></table></figure><p>在binarySort方法底层，会通过匿名内部类的compare</p><p>源码分析：</p><p>（1）Arrays.sort(arr, new Comparator<Integer>() {</p><p>（2）最终到TimSort类的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">binarySort</span><span class="params">(T[] a, <span class="type">int</span> lo, <span class="type">int</span> hi, <span class="type">int</span> start,</span></span><br><span class="line"><span class="params">                                   Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span> &#123;</span><br></pre></td></tr></table></figure><p>（3）执行到bunarySort方法，会根据动态绑定机制c.compare执行我们传入的匿名内部类的compare()</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (left &lt; right) &#123;</span><br><span class="line">    int mid = (left + right) &gt;&gt;&gt; 1;</span><br><span class="line">    if (c.compare(pivot, a[mid]) &lt; 0)</span><br><span class="line">        right = mid;</span><br><span class="line">    else</span><br><span class="line">        left = mid + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> o1-o2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）public int compare(Integer o1, Integer o2) 返回的值&gt;0还是&lt;0会影响整个排序结果</p></li><li><p>这就充分体系了 接口编程+匿名内部类的综合使用，将来底层框架和源码的使用方式，会非常常见</p></li></ul></li><li><p>binarySearch 二叉查找 </p><p>要求数组是有序的</p><p>如果数组中不存在该元素，就返回-(low+1)  low是如果存在的位置</p></li><li><p>copyOf 数组元素的复制</p></li><li><p>fill 数组元素的填充，可以理解成替换原来的函数</p></li><li><p>equals 比较两个数组元素内容是否完全一致</p></li><li><p>asList将一组值，转换成List集合</p><p>返回的asList编译类型List（接口）</p><p>asList运行类型java.util.Arrays#ArrayList,是Array类里面的内部类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">RandomAccess</span>, java.io.Serializable</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li></ol><h3 id="六、System类"><a href="#六、System类" class="headerlink" title="六、System类"></a>六、System类</h3><ol><li>exit 退出当前程序</li><li>arraycopy 复制数组，比较适合底层调用，一般用Arrays.copyOf完成复制数组</li><li>currentTimeMillens 返回当前时间距离1970-1-1的毫秒数</li><li>gc 运行垃圾回收机制</li></ol><h3 id="七、BigInteger和BigDecimal类（大数处理）"><a href="#七、BigInteger和BigDecimal类（大数处理）" class="headerlink" title="七、BigInteger和BigDecimal类（大数处理）"></a>七、BigInteger和BigDecimal类（大数处理）</h3><p>应用场景：</p><ul><li>BigInteger适合保存比较大的整型</li><li>BigDecimal适合保存精度更高的浮点型（小数）</li></ul><h2 id="七、集合"><a href="#七、集合" class="headerlink" title="七、集合"></a>七、集合</h2><p><img src="/./img/Java0.png" alt="集合"></p><h3 id="1-集合的好处"><a href="#1-集合的好处" class="headerlink" title="1.集合的好处"></a>1.集合的好处</h3><ol><li>可以动态保存任意多个对象，使用比较方便</li><li>提供了一系列操作对象的方法：add、remove、set、get等</li></ol><h3 id="2-集合体系图"><a href="#2-集合体系图" class="headerlink" title="2.集合体系图"></a>2.集合体系图</h3><ol><li><p>集合主要是两组（单列集合、双列集合）</p></li><li><p>Collection 接口有两个重要的子接口 List Set，他们的实现子类都是单列集合</p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220921101204100.png" alt="image-20220921101204100"></p></li><li><p>Map接口的实现子类是双列集合，存放的K-V</p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220921101009030.png" alt="image-20220921101009030"></p></li></ol><h3 id="3-Collection接口和常用方法"><a href="#3-Collection接口和常用方法" class="headerlink" title="3.Collection接口和常用方法"></a>3.Collection接口和常用方法</h3><ol><li>Collection实现子类可以存放多个元素，每个可以是Object</li><li>有些Collection的实现类，可以存放重复元素，有些不可以</li><li>有些Collection的实现类，可以是有序的（List），有些不是有序（Set）</li><li>Collection接口没有直接的实现子类，是通过它的子接口Set和List来实现的</li></ol><h4 id="①常用方法："><a href="#①常用方法：" class="headerlink" title="①常用方法："></a>①常用方法：</h4><ol><li>add 添加单个元素</li><li>remove 删除指定元素</li><li>contains 查找元素是否存在</li><li>size 获取元素个数</li><li>isEmpty 判断是否为空</li><li>clear 清空</li><li>addAll 添加多个元素</li><li>containsAll 查找多个元素是否都存在</li><li>removeAll 删除多个元素</li></ol><h4 id="②迭代器遍历"><a href="#②迭代器遍历" class="headerlink" title="②迭代器遍历"></a>②迭代器遍历</h4><ol><li><p>Iterator对象称为迭代器，主要用于遍历Collection集合中的元素</p></li><li><p>所有实现了Iterator接口的集合类都有一个Iterator()方法，用以返回一个实现Iterator接口的对象，即可以返回一个迭代器</p></li><li><p>使用步骤</p><p>1、得到对应的迭代器 Iterator iterator &#x3D; col.iterator();</p><p>2、使用while循环遍历</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;<span class="comment">//判断是否还有数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> Iterator.next();<span class="comment">//下移，返回下一个元素</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、有一个迭代快捷键itit</p><p>4、ctrl+J 可以显示所有快捷键</p></li><li><p>如果需要再次遍历，需要重置我们的迭代器 iterator &#x3D; col.iterator();</p></li></ol><h4 id="③增强for循环"><a href="#③增强for循环" class="headerlink" title="③增强for循环"></a>③增强for循环</h4><ul><li>增强for也可以直接在数组使用</li><li>底层仍然是迭代器，可以理解成简化版的迭代器</li><li>快捷键 I</li></ul><h3 id="3-1-List接口"><a href="#3-1-List接口" class="headerlink" title="3.1.List接口"></a>3.1.List接口</h3><ol><li><p>List接口是Collection接口的子接口</p></li><li><p>List集合类中元素有序（即添加顺序和取出顺序一致）、且可重复</p></li><li><p>List集合的每个元素都有对应的顺序索引，即支持索引</p></li><li><p>JDK API中List接口的实现类有</p><p>所有已知实现类： </p><p><a href="../../java/util/AbstractList.html">AbstractList</a> ， <a href="../../java/util/AbstractSequentialList.html">AbstractSequentialList</a> ，  <a href="../../java/util/ArrayList.html">ArrayList</a> ， <a href="../../javax/management/AttributeList.html">AttributeList</a> ， <a href="../../java/util/concurrent/CopyOnWriteArrayList.html">CopyOnWriteArrayList</a>  ， <a href="../../java/util/LinkedList.html">LinkedList</a> ，  <a href="../../javax/management/relation/RoleList.html">RoleList</a> ， <a href="../../javax/management/relation/RoleUnresolvedList.html">RoleUnresolvedList</a>  ， <a href="../../java/util/Stack.html">Stack</a> ， <a href="../../java/util/Vector.html">Vector</a></p></li></ol><h4 id="①常用方法"><a href="#①常用方法" class="headerlink" title="①常用方法"></a>①常用方法</h4><ol><li><p>void add(int index, Object ele):在 index 位置插入 ele 元素  </p></li><li><p>boolean addAll(int index, Collection eles):从 index 位置开始将 eles 中的所有元素添加进来  </p></li><li><p>Object get(int index):获取指定 index 位置的元素  </p></li><li><p>int indexOf(Object obj):返回 obj 在集合中首次出现的位置  </p></li><li><p>int lastIndexOf(Object obj):返回 obj 在当前集合中末次出现的位置  </p></li><li><p>Object remove(int index):移除指定 index 位置的元素， 并返回此元素  </p></li><li><p>Object set(int index, Object ele):设置指定 index 位置的元素为 ele , 相当于是替换  </p></li><li><p>List subList(int fromIndex, int toIndex):返回从 fromIndex 到 toIndex 位置的子集合  </p><p>注意：前闭后开</p></li></ol><h4 id="②三种遍历方式【ArrayList、LinkedList、Vector】"><a href="#②三种遍历方式【ArrayList、LinkedList、Vector】" class="headerlink" title="②三种遍历方式【ArrayList、LinkedList、Vector】"></a>②三种遍历方式【ArrayList、LinkedList、Vector】</h4><ol><li>使用iterator</li><li>增强for</li><li>使用普通for</li></ol><h4 id="③ArrayList注意事项"><a href="#③ArrayList注意事项" class="headerlink" title="③ArrayList注意事项"></a>③ArrayList注意事项</h4><ol><li>可以加入null，并且多个</li><li>是由数组来实现数据存储的</li><li>基本等同与Vector，除了ArrayList是线程不安全的（执行效率高），在多线程的情况下，不赞成用ArrayList（没有synchronized）</li></ol><h4 id="④ArrayList底层结构和源码分析"><a href="#④ArrayList底层结构和源码分析" class="headerlink" title="④ArrayList底层结构和源码分析"></a>④ArrayList底层结构和源码分析</h4><ol><li><p>ArrayList中维护了一个Object类型的数组elementData</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;<span class="comment">//transient 表示瞬间、短暂的，表示该属性不会被序列化</span></span><br></pre></td></tr></table></figure></li><li><p>当创建ArrayList对象的时候，如果使用的是无参构造器，则初始elementData容量为0，第一次添加，则扩容elementData为10，如需再次扩容则扩容为1.5倍</p></li><li><p>如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容，则直接扩容elementData为1.5倍</p></li></ol><p>源码分析1：</p><p>创建了一个空的elementData数组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行list.add</p><p>（1）先确定是否要扩容</p><p>（2）然后再执行赋值</p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220921223201018.png" alt="image-20220921223201018"></p><p>该方法确定minCapacity</p><p>（1）第一次扩容为10</p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220921223926972.png" alt="image-20220921223926972"></p><p>（1）modCount++ 记录集合被修改的次数</p><p>（2）如果element的大小不够，就调用grow()去扩容</p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220921224323942.png" alt="image-20220921224323942"></p><p>（1）针对扩容</p><p>（2）使用扩容机制来确定扩容到多大</p><p>（3）第一次newCapacity &#x3D; 10</p><p>（4）第二次及以后，按照1.5倍扩容</p><p>（5）扩容使用的是Arrays.copyof()（保证原先的数据还在里面）</p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220921225033665.png" alt="image-20220921225033665"></p><p>然后再一个一个返回</p><p>注意：idea默认情况下，debug显示的数据是简化过后的，如果需要看到完整的数据，需要设置</p><p>源码分析2（有参构造器）：</p><p>创建了一个指定大小elementData数组</p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220921230609559.png" alt="image-20220921230609559"></p><h4 id="⑤Vector注意事项"><a href="#⑤Vector注意事项" class="headerlink" title="⑤Vector注意事项"></a>⑤Vector注意事项</h4><ol><li><p>定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vector</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure></li><li><p>底层也是一个对象数组 protected Object[] elementData;</p></li><li><p>是线程同步的，即线程安全</p></li><li><p>再开发中，需要线程同步安全时，考虑使用Vector</p></li></ol><h4 id="⑥Vector源码分析"><a href="#⑥Vector源码分析" class="headerlink" title="⑥Vector源码分析"></a>⑥Vector源码分析</h4><p>回到上一步的快捷键 ctrl+alt+左键</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityHelper</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);<span class="comment">//扩容的算法</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑦Vector和ArrayList的比较"><a href="#⑦Vector和ArrayList的比较" class="headerlink" title="⑦Vector和ArrayList的比较"></a>⑦Vector和ArrayList的比较</h4><table><thead><tr><th></th><th>底层结构</th><th>版本</th><th>线程安全（同步）效率</th><th>扩容倍数</th></tr></thead><tbody><tr><td>ArrayList</td><td>可变数组</td><td>jdk1.2</td><td>不安全，效率高</td><td>有参构造1.5倍扩，如果是无参构造，第一次10，第二次开始1.5</td></tr><tr><td>Vector</td><td>可变数组</td><td>jdk1.0</td><td>安全，效率不高</td><td>无参构造，默认10，满后，2倍扩容，如果指定大小，则每次直接按两倍扩</td></tr></tbody></table><h4 id="⑧LinkedList底层结构"><a href="#⑧LinkedList底层结构" class="headerlink" title="⑧LinkedList底层结构"></a>⑧LinkedList底层结构</h4><p>实现了List接口</p><ol><li>底层实现了双向链表和双端队列的特点</li><li>可以添加任意元素（可以重复），包括null</li><li>线程不安全，没有同步</li></ol><p>底层操作机制：</p><ol><li>底层维护了一个双向链表</li><li>维护了两个属性first和last分别指向首节点和尾节点</li><li>每个节点（Node对象），里面又维护了prev、next、item三个属性</li><li>添加和删除，相对数组来说效率较高</li></ol><p>源码解析：</p><p>（添加）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时LinkedList的属性first &#x3D; null last&#x3D;null</p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220922223526297.png"></p><p>执行添加方法</p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220923234503158.png" alt="image-20220923234503158"></p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220923235058078.png" alt="image-20220923235058078"></p><p>源码解析：</p><p>（删除）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">linkedList.remove();</span><br></pre></td></tr></table></figure><p>默认是删除第一个</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220924000156110.png" alt="image-20220924000156110"></p><p>返回的是删除的值</p><h4 id="⑨ArrayList和LinkedList的比较"><a href="#⑨ArrayList和LinkedList的比较" class="headerlink" title="⑨ArrayList和LinkedList的比较"></a>⑨ArrayList和LinkedList的比较</h4><table><thead><tr><th></th><th>底层结构</th><th>增删的效率</th><th>改查的效率</th></tr></thead><tbody><tr><td>ArrayList</td><td>可变数组</td><td>较低，数组扩容</td><td>较高</td></tr><tr><td>LinkedList</td><td>双向链表</td><td>较高，通过链表追加</td><td>较低</td></tr></tbody></table><h3 id="3-2Set接口"><a href="#3-2Set接口" class="headerlink" title="3.2Set接口"></a>3.2Set接口</h3><ol><li><p>无序（添加和取出的顺序不一致，但是取出的顺序不变），没有索引</p></li><li><p>不允许重复，所以最多包含一个null</p></li><li><p>JDK API中所有已知实现类： </p><p><a href="../../java/util/AbstractSet.html">AbstractSet</a> ， <a href="../../java/util/concurrent/ConcurrentHashMap.KeySetView.html">ConcurrentHashMap.KeySetView</a>  ， <a href="../../java/util/concurrent/ConcurrentSkipListSet.html">ConcurrentSkipListSet</a>  ， <a href="../../java/util/concurrent/CopyOnWriteArraySet.html">CopyOnWriteArraySet</a>  ， <a href="../../java/util/EnumSet.html">EnumSet</a> ， <a href="../../java/util/HashSet.html">HashSet</a> ， <a href="../../javax/print/attribute/standard/JobStateReasons.html">JobStateReasons</a>  ， <a href="../../java/util/LinkedHashSet.html">LinkedHashSet</a> ， <a href="../../java/util/TreeSet.html">TreeSet</a></p></li></ol><p>常用方法和Collection接口一样</p><h4 id="①Set接口的遍历方式"><a href="#①Set接口的遍历方式" class="headerlink" title="①Set接口的遍历方式"></a>①Set接口的遍历方式</h4><ol><li>可以使用迭代器</li><li>增强for</li><li>不能使用索引的方式</li></ol><h4 id="②HashSet"><a href="#②HashSet" class="headerlink" title="②HashSet"></a>②HashSet</h4><ul><li>实现了Set接口，底层实际上是HashMap</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以存放null值</li><li>不保证元素是有序的，取决于hash后，再确定索引的结果（即，不保证添加顺序和取出顺序一致）</li><li>不能有重复的元素或对象</li></ul><h5 id="底层机制说明："><a href="#底层机制说明：" class="headerlink" title="底层机制说明："></a>底层机制说明：</h5><ol><li>底层是HashMap</li><li>添加一个元素时，先得到hash值-会转成-&gt;索引值</li><li>找到存储数据表table，看这个索引位置是否已经已经存放的有元素</li><li>如果没有，直接加入</li><li>如果有，调用equals比较，如果相同，就放弃添加，如果不相同，则添加到最后</li><li>在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认时8)，并且table的大小&gt;&#x3D;MIN_TREEIFY_CAPACITY(默认64)，就会进行树化（红黑树）</li></ol><h5 id="HashSet源码解读："><a href="#HashSet源码解读：" class="headerlink" title="HashSet源码解读："></a>HashSet源码解读：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">    hashSet.add(<span class="string">&quot;java&quot;</span>);<span class="comment">//到此位置， 第 1 次 add </span></span><br><span class="line">    hashSet.add(<span class="string">&quot;php&quot;</span>);<span class="comment">//到此位置， 第 2 次 add </span></span><br><span class="line">    hashSet.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;set=&quot;</span> + hashSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行构造器</p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220924101825744.png" alt="image-20220924101825744"></p><p>执行add()</p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220924101933764.png" alt="image-20220924101933764"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><p>PRESENT是静态的一个对象，用来占位的，为了HashSet能使用HashMap</p><p>执行put()，该方法会执行hash(key) 得到可以对应的hash值（不是完全等价于hashcode，因为里还有算法 return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220924102029996.png" alt="image-20220924102029996"></p><p>key&#x3D;”java” value&#x3D;PRESENT（共享）</p><p>执行putVal</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;<span class="comment">//定义辅助变量</span></span><br><span class="line">   <span class="comment">//table就是HashMap的一个数组，类型是Node[]</span></span><br><span class="line">    <span class="comment">//if语句表示，如果当前table是mull，或者大小=0</span></span><br><span class="line">    <span class="comment">//就是第一次扩容，到16个空间</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//(1)根据key，得到hash值，去计算该key应该存放到table表的哪个索引位置</span></span><br><span class="line">    <span class="comment">//并且把这个位置的对象，赋给p</span></span><br><span class="line">    <span class="comment">//(2)判断p 是否为空</span></span><br><span class="line">    <span class="comment">//(2.1)如果p为null，表示还没有存放元素，就创建一个Node(key=&quot;java&quot;,value=PRESENT)</span></span><br><span class="line">    <span class="comment">//(2.2)就放在该位置  tab[i] = newNode(hash, key, value, null);</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//一个开发技巧提示：在需要的局部变量（辅助变量）的时候再创建</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            <span class="comment">//如果当前索引位置对应的第一个元素和准备添加的key的hash值一样</span></span><br><span class="line">            <span class="comment">//并且满足下面两个条件之一</span></span><br><span class="line">            <span class="comment">//(1)准备加入的key和p指向的的Node节点的key是同一个对象</span></span><br><span class="line">            <span class="comment">//(2)p指向的Node节点的key的equals()和准备加入的key比较后相同</span></span><br><span class="line">               <span class="comment">//就不能加入</span></span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//再判断p是不是一颗红黑树</span></span><br><span class="line">        <span class="comment">//如果是一颗红黑树，就调用putTreeVal，来进行添加</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//如果table对应索引的位置，已经是一个链表，就使用for循环比较</span></span><br><span class="line">              <span class="comment">//(1)依次和该链表的每一个元素比较后，都不相同，则加入到该链表的最后</span></span><br><span class="line">               <span class="comment">//注意把元素添加到链表后，立即判断，该链表是否已经到达8个节点，如果到达，就调用</span></span><br><span class="line">               <span class="comment">//treeifyBin() 对当前这个链表进行树化（转成红黑树）</span></span><br><span class="line">               <span class="comment">//注意，在转成红黑树时要进行判断</span></span><br><span class="line">               <span class="comment">//if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span></span><br><span class="line">               <span class="comment">//resize();</span></span><br><span class="line">               <span class="comment">//如果上面条件成立，先table扩容</span></span><br><span class="line">               <span class="comment">//如果不成立，才转成红黑树</span></span><br><span class="line">             <span class="comment">//(2)依次和该链表的每一个元素比较过程中，如果有相同的情况，就直接break；  </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;<span class="comment">//死循环</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//size就是每加入一个节点Node，size就会++</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();<span class="comment">//扩容</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="HashSet的扩容和转成红黑树机制："><a href="#HashSet的扩容和转成红黑树机制：" class="headerlink" title="HashSet的扩容和转成红黑树机制："></a>HashSet的扩容和转成红黑树机制：</h5><ol><li><p>第一次添加时，table数组扩容到16，临界值（threshold）是16*加载因子（loadFactor）是0.75&#x3D;12</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure></li><li><p>如果table数组使用到了临界值12，就会扩容到16*2&#x3D;32，新的临界值就是32 * 0.75&#x3D;24，依次类推</p></li><li><p>Java8中…（红黑树）</p></li></ol><h4 id="③LinkeaHashSet"><a href="#③LinkeaHashSet" class="headerlink" title="③LinkeaHashSet"></a>③LinkeaHashSet</h4><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220924160039757.png" alt="image-20220924160039757"></p><ol><li><p>是HashSet的子类</p></li><li><p>底层是一个LinkedHashMap（是HashMap的子类），底层维护了一个数组+双向链表</p></li><li><p>根据元素的hashCode值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的</p></li><li><p>不允许添加重复元素</p></li><li><p>添加第一次的时候，直接将数组table扩容到16，存放的节点类型是LinkedHashMap$Entry</p></li><li><p>数组是] 存放的元素&#x2F;数据是LinkedHashMap$Entry类型</p><p>继承关系是在内部类完成</p></li></ol><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220924162542657.png" alt="image-20220924162542657"></p><h4 id="④TreeSet"><a href="#④TreeSet" class="headerlink" title="④TreeSet"></a>④TreeSet</h4><p>使用TreeSet提供的一个构造器，可以传入一个比较器（匿名内部类），并指定排序规则</p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220926180327513.png" alt="image-20220926180327513"></p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220926180919134.png" alt="image-20220926180919134"></p><p>这种方法替换的是value而不是key，因为set只考虑key，所以说来key是没有替换且加入不了的</p><h3 id="4-Map接口"><a href="#4-Map接口" class="headerlink" title="4.Map接口"></a>4.Map接口</h3><h4 id="①Map接口和常用方法"><a href="#①Map接口和常用方法" class="headerlink" title="①Map接口和常用方法"></a>①Map接口和常用方法</h4><h5 id="JDK8的map接口特点："><a href="#JDK8的map接口特点：" class="headerlink" title="JDK8的map接口特点："></a>JDK8的map接口特点：</h5><ol><li><p>Map和Collection并列存在。用于保存具有映射关系的数据：Key-value（双列元素）</p></li><li><p>Map中的key和value可以是任何引用类型的数据，会封装到HashMap$Node对象中</p></li><li><p>Map中的key不允许重复，当有相同的key，就等价于替换</p></li><li><p>Map中的value可以重复</p></li><li><p>Map 的 key 可以为 null, value 也可以为 null ， 注意 key 为 null,  只能有一个， value 为 null ,可以多个  </p></li><li><p>常用String类作为Map的key</p></li><li><p>k-v存在单向一对一关系</p></li><li><p>一对k-v是放在一个HashMap$Node中的，又因为Node实现了Entry接口，有些书上也说，一对k-v就是一个Entry</p></li><li><p>HashMap$Node node &#x3D; newNode(hash, key, value, null)</p></li><li><p>k-v为了方便程序员的遍历，还会创建EntrySet集合，，该集合存放的元素类型Entry，而一个Entry对象就有k，v  EntrySet&lt;Entry&lt;k,v&gt;&gt; 即：transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</p></li><li><p>entrySet中，定义的类型是Map.Entry，但是实际上存放的还是HashMap$Node，</p><p>这是因为static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {</p></li><li><p>当把HashMap$Node对象存放到entrySet就方便我们的遍历，因为Map.Entry提供了重要方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">K <span class="title function_">getKey</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">V <span class="title function_">getValue</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li><li><p>还提供了keySet(),values(),来方便分别遍历k，v</p></li></ol><h4 id="②Map六大遍历方式"><a href="#②Map六大遍历方式" class="headerlink" title="②Map六大遍历方式"></a>②Map六大遍历方式</h4><ol><li><p>第一组：先取出所有的key，通过key，取出对应的value</p><p>增强for、迭代器</p></li><li><p>第二组：把所有的values取出</p><p>这里可以使用所有Collections使用的遍历方法</p></li><li><p>第三组：通过EntrySet来获取k-v</p><p>增强for、迭代器</p></li></ol><h4 id="③HashMap"><a href="#③HashMap" class="headerlink" title="③HashMap"></a>③HashMap</h4><p>没有做同步互斥操作，线程不安全</p><h5 id="底层机制和源码剖析："><a href="#底层机制和源码剖析：" class="headerlink" title="底层机制和源码剖析："></a>底层机制和源码剖析：</h5><p>执行构造器</p><p>初始化加载因子</p><p>HashMap$Node[] table &#x3D; null</p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220926121526542.png" alt="image-20220926121526542"></p><p>执行input</p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220926141214797.png" alt="image-20220926141214797"></p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220926142140197.png" alt="image-20220926142140197"></p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220926143239911.png" alt="image-20220926143239911"></p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220926143500484.png" alt="image-20220926143500484"></p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220926144331525.png" alt="image-20220926144331525"></p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220926145009692.png" alt="image-20220926145009692"></p><h4 id="④HashTable"><a href="#④HashTable" class="headerlink" title="④HashTable"></a>④HashTable</h4><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220926160406322.png" alt="image-20220926160406322"></p><ol><li>存放的元素是键值对：即k-v</li><li>值和键都不能为空，否则会抛出NullPointterException</li><li>HashTable使用方法基本上和HashMap一样</li><li>HashTable是线程安全的（synchronized），hashMap是线程不安全的</li></ol><h5 id="底层结构："><a href="#底层结构：" class="headerlink" title="底层结构："></a>底层结构：</h5><ol><li>底层有数组 HashTable$Entry[] 初始化大小为11</li><li>threshold 8 &#x3D;  11 * 0.75</li><li>扩容：<img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220926162347901.png" alt="image-20220926162347901"></li></ol><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220926163517802.png" alt="image-20220926163517802"></p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220926163617104.png" alt="image-20220926163617104"></p><h4 id="⑤HashTable和HashMap对比"><a href="#⑤HashTable和HashMap对比" class="headerlink" title="⑤HashTable和HashMap对比"></a>⑤HashTable和HashMap对比</h4><table><thead><tr><th></th><th>版本</th><th>线程安全（同步）</th><th>效率</th><th>允许null键null值</th></tr></thead><tbody><tr><td>HashMap</td><td>1.2</td><td>不安全</td><td>高</td><td>可以</td></tr><tr><td>HashTable</td><td>1.0</td><td>安全</td><td>较低</td><td>不可以</td></tr></tbody></table><h4 id="⑥Properties"><a href="#⑥Properties" class="headerlink" title="⑥Properties"></a>⑥Properties</h4><ol><li>Properties类继承自HashTable类并且实现lMap接口，也是使用一种键值对的形式来保存数据</li><li>特点和HashTable类似</li><li>Properties还可以用于从XXX.properties文件中，加载数据到Properties类对象，并进行读取和修改</li><li>工作中XXX.properties文件通常作为配置文件</li></ol><h4 id="⑦TreeMap"><a href="#⑦TreeMap" class="headerlink" title="⑦TreeMap"></a>⑦TreeMap</h4><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220926201452426.png" alt="image-20220926201452426"></p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20220926201836611.png" alt="image-20220926201836611"></p><p>如果是相同的key，value值会被替换</p><h3 id="5-集合选型规则"><a href="#5-集合选型规则" class="headerlink" title="5.集合选型规则"></a>5.集合选型规则</h3><p>根据业务操作特点选择不同的集合类</p><ol><li><p>先判断存储的数据类型（一组对象【单列】或一组键值对【双列】）</p></li><li><p>一组对象[单列]：Collection接口</p><ul><li><p>允许重复：List</p><p>​                 增删多：LinkedList【底层维护了一个双向链表】</p><p>​                 该查多：ArrayList【底层维护Object类型的可变数组】</p></li><li><p>不允许重复：Set</p><p>​                 无序：HashSet【底层是HashMap，维护了一个哈希表 即（数组+链表+红黑树）】</p><p>​                 排序：TreeSet</p><p>​                 插入和取出顺序一致：LinkedHashSet，维护数组+双向链表</p></li></ul></li><li><p>一组键值对：Map</p><p>​        键无序：HashMap【底层是：哈希表 jdk7：数组+链表，jdk8：数组+链表+红黑树】</p><p>​        键排序：TreeMap</p><p>​        键插入和取出的顺序一致：LinkedHashMap</p><p>​        读取文件：Properties</p></li></ol><h3 id="6-Collections工具类"><a href="#6-Collections工具类" class="headerlink" title="6.Collections工具类"></a>6.Collections工具类</h3><h4 id="①常用方法-1"><a href="#①常用方法-1" class="headerlink" title="①常用方法"></a>①常用方法</h4><ul><li>reverse(List) 反转List中元素的顺序</li><li>shuffle(List) 对List集合元素进行随机排序</li><li>sort(List) 根据元素的自然排序对指定List集合元素按升序排序   也可以根据指定的Comparator产生的顺序对List集合排序</li><li>Object max(Collection) 根据元素的自然顺序，返回给定集合中的最大元素</li><li>Object max(Collection,Comparator) 根据Comparator指定的顺序，返回给定集合中的最大元素</li><li>Object min(Collection)，Object min(Collection,Comparator) </li><li>int frequency(Collection,Object) 返回指定集合中指定元素的出现次数</li><li>void copy(List dest,List src) 将src中的内容复制到dest中</li><li>swap(List list,int i,int j) 将指定list集合中的i处元素和j处元素进行交换</li><li>boolean replaceAll()(List list,Object oldVal,Object newVal) 使用新值替换List对象的所有旧值</li></ul><h2 id="八、多线程"><a href="#八、多线程" class="headerlink" title="八、多线程"></a>八、多线程</h2><h3 id="一、进程"><a href="#一、进程" class="headerlink" title="一、进程"></a>一、进程</h3><ol><li>进程是指运行中的程序，比如我们使用QQ，就启动了一个进程，操作系统就会为该进程分配内存空间</li><li>进程是指程序的一次执行过程，或是正在运行的一个程序。是动态过程：有它自身产生、存在和消亡的过程</li></ol><h3 id="二、线程"><a href="#二、线程" class="headerlink" title="二、线程"></a>二、线程</h3><ol><li>线程是由进程创建的，是进程的一个实体</li><li>一个进程可以拥有多个线程</li></ol><h3 id="三、并发和并行"><a href="#三、并发和并行" class="headerlink" title="三、并发和并行"></a>三、并发和并行</h3><p>并发：同一个时刻，多个任务交替执行，造成一种“貌似同时”的错觉，简单的说，单核cpu实现的多任务就是并发</p><p>并行：同一个时刻，多个任务同时执行，多核cpu可以实现并行。也有并发和并行同时有的</p><h3 id="四、线程的基本使用"><a href="#四、线程的基本使用" class="headerlink" title="四、线程的基本使用"></a>四、线程的基本使用</h3><h4 id="①创建线程的两种方法"><a href="#①创建线程的两种方法" class="headerlink" title="①创建线程的两种方法"></a>①创建线程的两种方法</h4><h6 id="继承Thread类："><a href="#继承Thread类：" class="headerlink" title="继承Thread类："></a>继承Thread类：</h6><ol><li><p>当一个类继承了Thread类，该类可以当作线程使用</p></li><li><p>我们会重写run方法，写上自己的业务代码</p><p>run方法就是一个普通的方法，没有真正地启动一个线程，就会把run方法执行完毕，才向下执行</p></li><li><p>run  Thread类实现了Runnable接口的run方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多线程机制</p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20221005152035729.png" alt="image-20221005152035729"></p></li><li><p>源码解读</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">start0();</span><br></pre></td></tr></table></figure><p>start0()是本地方法，是JVM调用，底层是c&#x2F;c++实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>真正实现多线程的效果，是start0()，而不是run</p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20221005153001138.png" alt="image-20221005153001138"></p><h6 id="实现Runnable接口："><a href="#实现Runnable接口：" class="headerlink" title="实现Runnable接口："></a>实现Runnable接口：</h6><p>这里底层使用了设计模式【代理模式】</p><p>演示静态代理模式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Dog dog = new Dog();</span></span><br><span class="line"><span class="comment">//        Thread thread = new Thread(dog);</span></span><br><span class="line"><span class="comment">//        thread.start();</span></span><br><span class="line">        <span class="type">Tiger</span> <span class="variable">tiger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tiger</span>();</span><br><span class="line">        <span class="type">ThreadProxy</span> <span class="variable">threadProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadProxy</span>(tiger);</span><br><span class="line">        threadProxy.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tiger</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老虎嗷嗷叫...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadProxy</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>)&#123;</span><br><span class="line">            target.run();<span class="comment">//动态绑定（运行类型）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadProxy</span><span class="params">(Runnable target)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        start0();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>&#123;</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小狗汪汪叫...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="两种方法的区别："><a href="#两种方法的区别：" class="headerlink" title="两种方法的区别："></a>两种方法的区别：</h6><ol><li>从Java设计来看，本质是没有区别的，从jdk帮助文档我们可以看到Thread类本身就实现了Runnable接口start()-&gt;start0()</li><li>实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制</li><li>建议使用Runnable接口</li></ol><h4 id="②线程终止"><a href="#②线程终止" class="headerlink" title="②线程终止"></a>②线程终止</h4><ol><li>当线程完成任务后，会自动退出</li><li>还可以通过使用变量来控制run方法退出的方式停止线程，即通知方式</li></ol><h4 id="③线程常用方法"><a href="#③线程常用方法" class="headerlink" title="③线程常用方法"></a>③线程常用方法</h4><p>常用方法第一组：</p><ul><li>setName 设置线程名称，使之与参数name相同</li><li>getName 返回该线程的名称</li><li>start 使该线程开始执行；Java虚拟机底层调用该线程的start0方法</li><li>run 调用线程对象run方法</li><li>setPriority 更改线程的优先级</li><li>getPriority  获取线程的优先级</li><li>sleep 在指定的毫秒数内让正在执行的线程休眠（暂停使用）</li><li>interrupt 中断线程</li></ul><p>注意事项和细节：</p><ol><li><p>start底层会创建新的线程，调用run，，run就是一个简单的方法调用，不会启动新线程</p></li><li><p>线程优先级的范围</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The minimum priority that a thread can have.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MIN_PRIORITY</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The default priority that is assigned to a thread.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NORM_PRIORITY</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The maximum priority that a thread can have.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX_PRIORITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>interrupt，中断线程，但并没有真正的结束线程，所以一般用于中断正在休眠线程</p></li><li><p>sleep 线程的静态方法，使当前线程休眠</p></li></ol><p>常用方法第二组：</p><ol><li>yield：线程的礼让。让出cpu，让其他线程执行，但礼让的时间不确定，所以也不一定不一定礼让成功</li><li>join：线程的插队。插队的线程一旦插入成功，则肯定先执行完插入的线程的所有任务</li></ol><h4 id="④用户线程和守护线程"><a href="#④用户线程和守护线程" class="headerlink" title="④用户线程和守护线程"></a>④用户线程和守护线程</h4><ol><li>用户线程：也叫工作线程，当线程的任务执行完毕或通知方法结束</li><li>守护线程：一般是为工作线程服务的，当所有用户的用户线程结束，守护线程自动结束</li><li>常见的守护线程：垃圾回收机制</li><li>setDaemon()</li></ol><h4 id="⑤线程的生命周期"><a href="#⑤线程的生命周期" class="headerlink" title="⑤线程的生命周期"></a>⑤线程的生命周期</h4><p>官方文档里面：</p><p>public static enum Thread.State<br>extends Enum&lt;Thread.State&gt;</p><p>线程状态。线程可以处于以下状态之一：</p><ul><li><a href="../../java/lang/Thread.State.html#NEW"><code>NEW</code></a><br>尚未启动的线程处于此状态。 </li><li><a href="../../java/lang/Thread.State.html#RUNNABLE"><code>RUNNABLE</code></a><br>在Java虚拟机中执行的线程处于此状态。 </li><li><a href="../../java/lang/Thread.State.html#BLOCKED"><code>BLOCKED</code></a><br>被阻塞等待监视器锁定的线程处于此状态。 </li><li><a href="../../java/lang/Thread.State.html#WAITING"><code>WAITING</code></a><br>正在等待另一个线程执行特定动作的线程处于此状态。 </li><li><a href="../../java/lang/Thread.State.html#TIMED_WAITING"><code>TIMED_WAITING</code></a><br>正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。 </li><li><a href="../../java/lang/Thread.State.html#TERMINATED"><code>TERMINATED</code></a><br>已退出的线程处于此状态。</li></ul><p>一个线程可以在给定时间点处于一个状态。 这些状态是不反映任何操作系统线程状态的虚拟机状态。 </p><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20221007140720757.png" alt="image-20221007140720757"></p><h4 id="⑥线程同步机制"><a href="#⑥线程同步机制" class="headerlink" title="⑥线程同步机制"></a>⑥线程同步机制</h4><ol><li><p>在多线程编程，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何同一时刻，最多有一个线程同时访问，以保证数据的完整性</p></li><li><p>线程同步，即当有一个线程对内存进行操作的时候，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作</p></li><li><p>同步具体方法</p><ul><li><p>同步代码块</p><p>synchronized(对象) {&#x2F;&#x2F;得到对象的锁，才能操作同步代码块</p><p>&#x2F;&#x2F;需要被同步代码；</p><p>}</p></li><li><p>synchronized还可以放在方法声明中，表示整个方法为同步方法</p><p>public synchronized void m(String name){</p><p>&#x2F;&#x2F;需要被同步的代码</p><p>}</p></li></ul></li></ol><h4 id="⑦互斥锁"><a href="#⑦互斥锁" class="headerlink" title="⑦互斥锁"></a>⑦互斥锁</h4><ol><li>Java语言中，引入了对象互斥的概念，来保证共享数据的完整性</li><li>每个对象都对应一个可称为“互斥锁”的标记，这个标记保证在任一时刻，只能有一个线程访问对象</li><li>关键字synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一个线程访问</li><li>同步的局限性：导致程序的执行效率降低</li><li>同步方法（非静态的）的锁可以是this，也可以是其他对象（要求是同一个对象）</li><li>同步方法（静态的）的锁为当前类本身</li></ol><p>实现的落地步骤：</p><ul><li>需要先分析上锁的代码</li><li>选择<strong>同步代码块</strong>（推荐）或同步方法</li><li>要求多个线程的锁对象为同一个即可</li></ul><h4 id="⑧线程的死锁"><a href="#⑧线程的死锁" class="headerlink" title="⑧线程的死锁"></a>⑧线程的死锁</h4><p>多个线程都占用了对方的锁资源，但不肯相让，导致了死锁，在编程中是一定要避免死锁的发生</p><h4 id="⑨释放锁"><a href="#⑨释放锁" class="headerlink" title="⑨释放锁"></a>⑨释放锁</h4><p>下面操作会释放锁：</p><ol><li>当前线程的同步方法、同步代码块执行结束</li><li>当前线程在同步代码块、同步方法中遇到break、return</li><li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束</li><li>当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁</li></ol><p>下面操作不会释放锁：</p><ol><li>线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行，不会释放锁</li><li>线程执行同步代码块的时候，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁</li><li>提示：应尽量避免使用suspend()和resume()来控制线程，方法不再推荐使用</li></ol><h2 id="九、反射"><a href="#九、反射" class="headerlink" title="九、反射"></a>九、反射</h2><h3 id="一、反射机制"><a href="#一、反射机制" class="headerlink" title="一、反射机制"></a>一、反射机制</h3><h4 id="①一个需求引出反射"><a href="#①一个需求引出反射" class="headerlink" title="①一个需求引出反射"></a>①一个需求引出反射</h4><ol><li>需求：根据配置文件指定信息，创建对象并调用方法</li><li>这样的需求在学习框架时特别多，即通过外部文件配置，在不修改源码情况下，来控制程序，也符合设计模式的ocp原则（开闭原则：不修改源码，扩容功能）</li></ol><h4 id="②反射快速入门"><a href="#②反射快速入门" class="headerlink" title="②反射快速入门"></a>②反射快速入门</h4><ol><li><p>加载类，返回Class类型的对象</p><p>Class cls &#x3D; Class.forName(classfullpath)</p></li><li><p>通过对象得到加载的类的对象实例</p><p>Object o &#x3D; cls.newInstance()</p></li><li><p>通过cls得到加载的类的方法对象</p><p>Method method1 &#x3D; cls.getMethod(emthodName)</p></li><li><p>通过method1调用方法：即通过方法对象来调用方法</p><p>method.invoke(o)&#x2F;&#x2F;传统方法 对象.方法(),反射机制 方法.invoke(对象)</p></li></ol><h4 id="③Java反射机制原理图"><a href="#③Java反射机制原理图" class="headerlink" title="③Java反射机制原理图"></a>③Java反射机制原理图</h4><p><img src="/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0.assets/image-20221008112727529.png" alt="image-20221008112727529"></p><h4 id="④反射相关类"><a href="#④反射相关类" class="headerlink" title="④反射相关类"></a>④反射相关类</h4><ol><li>java.lang.Class:代表一个类，Class对象表示某个类加载后在堆中的对象</li><li>java.lang.reflect.Method:</li><li></li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
